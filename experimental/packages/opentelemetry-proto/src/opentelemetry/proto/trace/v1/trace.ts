/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.15.6
 * source: opentelemetry/proto/trace/v1/trace.proto
 * git: https://github.com/thesayyn/protoc-gen-ts
 *  */
import * as dependency_1 from "./../../common/v1/common";
import * as dependency_2 from "./../../resource/v1/resource";
import * as pb_1 from "google-protobuf";
export namespace opentelemetry.proto.trace.v1 {
    export class TracesData extends pb_1.Message {
        constructor(data?: any[] | {
            resource_spans?: ResourceSpans[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("resource_spans" in data && data.resource_spans != undefined) {
                    this.resource_spans = data.resource_spans;
                }
            }
        }
        get resource_spans() {
            return pb_1.Message.getRepeatedWrapperField(this, ResourceSpans, 1) as ResourceSpans[];
        }
        set resource_spans(value: ResourceSpans[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            resource_spans?: ReturnType<typeof ResourceSpans.prototype.toObject>[];
        }) {
            const message = new TracesData({});
            if (data.resource_spans != null) {
                message.resource_spans = data.resource_spans.map(item => ResourceSpans.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                resource_spans?: ReturnType<typeof ResourceSpans.prototype.toObject>[];
            } = {};
            if (this.resource_spans != null) {
                data.resource_spans = this.resource_spans.map((item: ResourceSpans) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.resource_spans !== undefined)
                writer.writeRepeatedMessage(1, this.resource_spans, (item: ResourceSpans) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TracesData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TracesData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.resource_spans, () => pb_1.Message.addToRepeatedWrapperField(message, 1, ResourceSpans.deserialize(reader), ResourceSpans));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TracesData {
            return TracesData.deserialize(bytes);
        }
    }
    export class ResourceSpans extends pb_1.Message {
        constructor(data?: any[] | {
            resource?: dependency_2.opentelemetry.proto.resource.v1.Resource;
            instrumentation_library_spans?: InstrumentationLibrarySpans[];
            schema_url?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("resource" in data && data.resource != undefined) {
                    this.resource = data.resource;
                }
                if ("instrumentation_library_spans" in data && data.instrumentation_library_spans != undefined) {
                    this.instrumentation_library_spans = data.instrumentation_library_spans;
                }
                if ("schema_url" in data && data.schema_url != undefined) {
                    this.schema_url = data.schema_url;
                }
            }
        }
        get resource() {
            return pb_1.Message.getWrapperField(this, dependency_2.opentelemetry.proto.resource.v1.Resource, 1) as dependency_2.opentelemetry.proto.resource.v1.Resource;
        }
        set resource(value: dependency_2.opentelemetry.proto.resource.v1.Resource) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get instrumentation_library_spans() {
            return pb_1.Message.getRepeatedWrapperField(this, InstrumentationLibrarySpans, 2) as InstrumentationLibrarySpans[];
        }
        set instrumentation_library_spans(value: InstrumentationLibrarySpans[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get schema_url() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set schema_url(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            resource?: ReturnType<typeof dependency_2.opentelemetry.proto.resource.v1.Resource.prototype.toObject>;
            instrumentation_library_spans?: ReturnType<typeof InstrumentationLibrarySpans.prototype.toObject>[];
            schema_url?: string;
        }) {
            const message = new ResourceSpans({});
            if (data.resource != null) {
                message.resource = dependency_2.opentelemetry.proto.resource.v1.Resource.fromObject(data.resource);
            }
            if (data.instrumentation_library_spans != null) {
                message.instrumentation_library_spans = data.instrumentation_library_spans.map(item => InstrumentationLibrarySpans.fromObject(item));
            }
            if (data.schema_url != null) {
                message.schema_url = data.schema_url;
            }
            return message;
        }
        toObject() {
            const data: {
                resource?: ReturnType<typeof dependency_2.opentelemetry.proto.resource.v1.Resource.prototype.toObject>;
                instrumentation_library_spans?: ReturnType<typeof InstrumentationLibrarySpans.prototype.toObject>[];
                schema_url?: string;
            } = {};
            if (this.resource != null) {
                data.resource = this.resource.toObject();
            }
            if (this.instrumentation_library_spans != null) {
                data.instrumentation_library_spans = this.instrumentation_library_spans.map((item: InstrumentationLibrarySpans) => item.toObject());
            }
            if (this.schema_url != null) {
                data.schema_url = this.schema_url;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.resource !== undefined)
                writer.writeMessage(1, this.resource, () => this.resource.serialize(writer));
            if (this.instrumentation_library_spans !== undefined)
                writer.writeRepeatedMessage(2, this.instrumentation_library_spans, (item: InstrumentationLibrarySpans) => item.serialize(writer));
            if (typeof this.schema_url === "string" && this.schema_url.length)
                writer.writeString(3, this.schema_url);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ResourceSpans {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ResourceSpans();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.resource, () => message.resource = dependency_2.opentelemetry.proto.resource.v1.Resource.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.instrumentation_library_spans, () => pb_1.Message.addToRepeatedWrapperField(message, 2, InstrumentationLibrarySpans.deserialize(reader), InstrumentationLibrarySpans));
                        break;
                    case 3:
                        message.schema_url = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ResourceSpans {
            return ResourceSpans.deserialize(bytes);
        }
    }
    export class InstrumentationLibrarySpans extends pb_1.Message {
        constructor(data?: any[] | {
            instrumentation_library?: dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary;
            spans?: Span[];
            schema_url?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("instrumentation_library" in data && data.instrumentation_library != undefined) {
                    this.instrumentation_library = data.instrumentation_library;
                }
                if ("spans" in data && data.spans != undefined) {
                    this.spans = data.spans;
                }
                if ("schema_url" in data && data.schema_url != undefined) {
                    this.schema_url = data.schema_url;
                }
            }
        }
        get instrumentation_library() {
            return pb_1.Message.getWrapperField(this, dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary, 1) as dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary;
        }
        set instrumentation_library(value: dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get spans() {
            return pb_1.Message.getRepeatedWrapperField(this, Span, 2) as Span[];
        }
        set spans(value: Span[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get schema_url() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set schema_url(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            instrumentation_library?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary.prototype.toObject>;
            spans?: ReturnType<typeof Span.prototype.toObject>[];
            schema_url?: string;
        }) {
            const message = new InstrumentationLibrarySpans({});
            if (data.instrumentation_library != null) {
                message.instrumentation_library = dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary.fromObject(data.instrumentation_library);
            }
            if (data.spans != null) {
                message.spans = data.spans.map(item => Span.fromObject(item));
            }
            if (data.schema_url != null) {
                message.schema_url = data.schema_url;
            }
            return message;
        }
        toObject() {
            const data: {
                instrumentation_library?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary.prototype.toObject>;
                spans?: ReturnType<typeof Span.prototype.toObject>[];
                schema_url?: string;
            } = {};
            if (this.instrumentation_library != null) {
                data.instrumentation_library = this.instrumentation_library.toObject();
            }
            if (this.spans != null) {
                data.spans = this.spans.map((item: Span) => item.toObject());
            }
            if (this.schema_url != null) {
                data.schema_url = this.schema_url;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.instrumentation_library !== undefined)
                writer.writeMessage(1, this.instrumentation_library, () => this.instrumentation_library.serialize(writer));
            if (this.spans !== undefined)
                writer.writeRepeatedMessage(2, this.spans, (item: Span) => item.serialize(writer));
            if (typeof this.schema_url === "string" && this.schema_url.length)
                writer.writeString(3, this.schema_url);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): InstrumentationLibrarySpans {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new InstrumentationLibrarySpans();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.instrumentation_library, () => message.instrumentation_library = dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.spans, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Span.deserialize(reader), Span));
                        break;
                    case 3:
                        message.schema_url = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): InstrumentationLibrarySpans {
            return InstrumentationLibrarySpans.deserialize(bytes);
        }
    }
    export class Span extends pb_1.Message {
        constructor(data?: any[] | {
            trace_id?: Uint8Array;
            span_id?: Uint8Array;
            trace_state?: string;
            parent_span_id?: Uint8Array;
            name?: string;
            kind?: Span.SpanKind;
            start_time_unix_nano?: number;
            end_time_unix_nano?: number;
            attributes?: dependency_1.opentelemetry.proto.common.v1.KeyValue[];
            dropped_attributes_count?: number;
            events?: Span.Event[];
            dropped_events_count?: number;
            links?: Span.Link[];
            dropped_links_count?: number;
            status?: Status;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [9, 11, 13], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("trace_id" in data && data.trace_id != undefined) {
                    this.trace_id = data.trace_id;
                }
                if ("span_id" in data && data.span_id != undefined) {
                    this.span_id = data.span_id;
                }
                if ("trace_state" in data && data.trace_state != undefined) {
                    this.trace_state = data.trace_state;
                }
                if ("parent_span_id" in data && data.parent_span_id != undefined) {
                    this.parent_span_id = data.parent_span_id;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("kind" in data && data.kind != undefined) {
                    this.kind = data.kind;
                }
                if ("start_time_unix_nano" in data && data.start_time_unix_nano != undefined) {
                    this.start_time_unix_nano = data.start_time_unix_nano;
                }
                if ("end_time_unix_nano" in data && data.end_time_unix_nano != undefined) {
                    this.end_time_unix_nano = data.end_time_unix_nano;
                }
                if ("attributes" in data && data.attributes != undefined) {
                    this.attributes = data.attributes;
                }
                if ("dropped_attributes_count" in data && data.dropped_attributes_count != undefined) {
                    this.dropped_attributes_count = data.dropped_attributes_count;
                }
                if ("events" in data && data.events != undefined) {
                    this.events = data.events;
                }
                if ("dropped_events_count" in data && data.dropped_events_count != undefined) {
                    this.dropped_events_count = data.dropped_events_count;
                }
                if ("links" in data && data.links != undefined) {
                    this.links = data.links;
                }
                if ("dropped_links_count" in data && data.dropped_links_count != undefined) {
                    this.dropped_links_count = data.dropped_links_count;
                }
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
            }
        }
        get trace_id() {
            return pb_1.Message.getField(this, 1) as Uint8Array;
        }
        set trace_id(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get span_id() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set span_id(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get trace_state() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set trace_state(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get parent_span_id() {
            return pb_1.Message.getField(this, 4) as Uint8Array;
        }
        set parent_span_id(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get name() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get kind() {
            return pb_1.Message.getField(this, 6) as Span.SpanKind;
        }
        set kind(value: Span.SpanKind) {
            pb_1.Message.setField(this, 6, value);
        }
        get start_time_unix_nano() {
            return pb_1.Message.getField(this, 7) as number;
        }
        set start_time_unix_nano(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get end_time_unix_nano() {
            return pb_1.Message.getField(this, 8) as number;
        }
        set end_time_unix_nano(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get attributes() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.KeyValue, 9) as dependency_1.opentelemetry.proto.common.v1.KeyValue[];
        }
        set attributes(value: dependency_1.opentelemetry.proto.common.v1.KeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 9, value);
        }
        get dropped_attributes_count() {
            return pb_1.Message.getField(this, 10) as number;
        }
        set dropped_attributes_count(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        get events() {
            return pb_1.Message.getRepeatedWrapperField(this, Span.Event, 11) as Span.Event[];
        }
        set events(value: Span.Event[]) {
            pb_1.Message.setRepeatedWrapperField(this, 11, value);
        }
        get dropped_events_count() {
            return pb_1.Message.getField(this, 12) as number;
        }
        set dropped_events_count(value: number) {
            pb_1.Message.setField(this, 12, value);
        }
        get links() {
            return pb_1.Message.getRepeatedWrapperField(this, Span.Link, 13) as Span.Link[];
        }
        set links(value: Span.Link[]) {
            pb_1.Message.setRepeatedWrapperField(this, 13, value);
        }
        get dropped_links_count() {
            return pb_1.Message.getField(this, 14) as number;
        }
        set dropped_links_count(value: number) {
            pb_1.Message.setField(this, 14, value);
        }
        get status() {
            return pb_1.Message.getWrapperField(this, Status, 15) as Status;
        }
        set status(value: Status) {
            pb_1.Message.setWrapperField(this, 15, value);
        }
        static fromObject(data: {
            trace_id?: Uint8Array;
            span_id?: Uint8Array;
            trace_state?: string;
            parent_span_id?: Uint8Array;
            name?: string;
            kind?: Span.SpanKind;
            start_time_unix_nano?: number;
            end_time_unix_nano?: number;
            attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
            dropped_attributes_count?: number;
            events?: ReturnType<typeof Span.Event.prototype.toObject>[];
            dropped_events_count?: number;
            links?: ReturnType<typeof Span.Link.prototype.toObject>[];
            dropped_links_count?: number;
            status?: ReturnType<typeof Status.prototype.toObject>;
        }) {
            const message = new Span({});
            if (data.trace_id != null) {
                message.trace_id = data.trace_id;
            }
            if (data.span_id != null) {
                message.span_id = data.span_id;
            }
            if (data.trace_state != null) {
                message.trace_state = data.trace_state;
            }
            if (data.parent_span_id != null) {
                message.parent_span_id = data.parent_span_id;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.kind != null) {
                message.kind = data.kind;
            }
            if (data.start_time_unix_nano != null) {
                message.start_time_unix_nano = data.start_time_unix_nano;
            }
            if (data.end_time_unix_nano != null) {
                message.end_time_unix_nano = data.end_time_unix_nano;
            }
            if (data.attributes != null) {
                message.attributes = data.attributes.map(item => dependency_1.opentelemetry.proto.common.v1.KeyValue.fromObject(item));
            }
            if (data.dropped_attributes_count != null) {
                message.dropped_attributes_count = data.dropped_attributes_count;
            }
            if (data.events != null) {
                message.events = data.events.map(item => Span.Event.fromObject(item));
            }
            if (data.dropped_events_count != null) {
                message.dropped_events_count = data.dropped_events_count;
            }
            if (data.links != null) {
                message.links = data.links.map(item => Span.Link.fromObject(item));
            }
            if (data.dropped_links_count != null) {
                message.dropped_links_count = data.dropped_links_count;
            }
            if (data.status != null) {
                message.status = Status.fromObject(data.status);
            }
            return message;
        }
        toObject() {
            const data: {
                trace_id?: Uint8Array;
                span_id?: Uint8Array;
                trace_state?: string;
                parent_span_id?: Uint8Array;
                name?: string;
                kind?: Span.SpanKind;
                start_time_unix_nano?: number;
                end_time_unix_nano?: number;
                attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                dropped_attributes_count?: number;
                events?: ReturnType<typeof Span.Event.prototype.toObject>[];
                dropped_events_count?: number;
                links?: ReturnType<typeof Span.Link.prototype.toObject>[];
                dropped_links_count?: number;
                status?: ReturnType<typeof Status.prototype.toObject>;
            } = {};
            if (this.trace_id != null) {
                data.trace_id = this.trace_id;
            }
            if (this.span_id != null) {
                data.span_id = this.span_id;
            }
            if (this.trace_state != null) {
                data.trace_state = this.trace_state;
            }
            if (this.parent_span_id != null) {
                data.parent_span_id = this.parent_span_id;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.kind != null) {
                data.kind = this.kind;
            }
            if (this.start_time_unix_nano != null) {
                data.start_time_unix_nano = this.start_time_unix_nano;
            }
            if (this.end_time_unix_nano != null) {
                data.end_time_unix_nano = this.end_time_unix_nano;
            }
            if (this.attributes != null) {
                data.attributes = this.attributes.map((item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.toObject());
            }
            if (this.dropped_attributes_count != null) {
                data.dropped_attributes_count = this.dropped_attributes_count;
            }
            if (this.events != null) {
                data.events = this.events.map((item: Span.Event) => item.toObject());
            }
            if (this.dropped_events_count != null) {
                data.dropped_events_count = this.dropped_events_count;
            }
            if (this.links != null) {
                data.links = this.links.map((item: Span.Link) => item.toObject());
            }
            if (this.dropped_links_count != null) {
                data.dropped_links_count = this.dropped_links_count;
            }
            if (this.status != null) {
                data.status = this.status.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.trace_id !== undefined)
                writer.writeBytes(1, this.trace_id);
            if (this.span_id !== undefined)
                writer.writeBytes(2, this.span_id);
            if (typeof this.trace_state === "string" && this.trace_state.length)
                writer.writeString(3, this.trace_state);
            if (this.parent_span_id !== undefined)
                writer.writeBytes(4, this.parent_span_id);
            if (typeof this.name === "string" && this.name.length)
                writer.writeString(5, this.name);
            if (this.kind !== undefined)
                writer.writeEnum(6, this.kind);
            if (this.start_time_unix_nano !== undefined)
                writer.writeFixed64(7, this.start_time_unix_nano);
            if (this.end_time_unix_nano !== undefined)
                writer.writeFixed64(8, this.end_time_unix_nano);
            if (this.attributes !== undefined)
                writer.writeRepeatedMessage(9, this.attributes, (item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.serialize(writer));
            if (this.dropped_attributes_count !== undefined)
                writer.writeUint32(10, this.dropped_attributes_count);
            if (this.events !== undefined)
                writer.writeRepeatedMessage(11, this.events, (item: Span.Event) => item.serialize(writer));
            if (this.dropped_events_count !== undefined)
                writer.writeUint32(12, this.dropped_events_count);
            if (this.links !== undefined)
                writer.writeRepeatedMessage(13, this.links, (item: Span.Link) => item.serialize(writer));
            if (this.dropped_links_count !== undefined)
                writer.writeUint32(14, this.dropped_links_count);
            if (this.status !== undefined)
                writer.writeMessage(15, this.status, () => this.status.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Span {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Span();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.trace_id = reader.readBytes();
                        break;
                    case 2:
                        message.span_id = reader.readBytes();
                        break;
                    case 3:
                        message.trace_state = reader.readString();
                        break;
                    case 4:
                        message.parent_span_id = reader.readBytes();
                        break;
                    case 5:
                        message.name = reader.readString();
                        break;
                    case 6:
                        message.kind = reader.readEnum();
                        break;
                    case 7:
                        message.start_time_unix_nano = reader.readFixed64();
                        break;
                    case 8:
                        message.end_time_unix_nano = reader.readFixed64();
                        break;
                    case 9:
                        reader.readMessage(message.attributes, () => pb_1.Message.addToRepeatedWrapperField(message, 9, dependency_1.opentelemetry.proto.common.v1.KeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.KeyValue));
                        break;
                    case 10:
                        message.dropped_attributes_count = reader.readUint32();
                        break;
                    case 11:
                        reader.readMessage(message.events, () => pb_1.Message.addToRepeatedWrapperField(message, 11, Span.Event.deserialize(reader), Span.Event));
                        break;
                    case 12:
                        message.dropped_events_count = reader.readUint32();
                        break;
                    case 13:
                        reader.readMessage(message.links, () => pb_1.Message.addToRepeatedWrapperField(message, 13, Span.Link.deserialize(reader), Span.Link));
                        break;
                    case 14:
                        message.dropped_links_count = reader.readUint32();
                        break;
                    case 15:
                        reader.readMessage(message.status, () => message.status = Status.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Span {
            return Span.deserialize(bytes);
        }
    }
    export namespace Span {
        export enum SpanKind {
            SPAN_KIND_UNSPECIFIED = 0,
            SPAN_KIND_INTERNAL = 1,
            SPAN_KIND_SERVER = 2,
            SPAN_KIND_CLIENT = 3,
            SPAN_KIND_PRODUCER = 4,
            SPAN_KIND_CONSUMER = 5
        }
        export class Event extends pb_1.Message {
            constructor(data?: any[] | {
                time_unix_nano?: number;
                name?: string;
                attributes?: dependency_1.opentelemetry.proto.common.v1.KeyValue[];
                dropped_attributes_count?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("time_unix_nano" in data && data.time_unix_nano != undefined) {
                        this.time_unix_nano = data.time_unix_nano;
                    }
                    if ("name" in data && data.name != undefined) {
                        this.name = data.name;
                    }
                    if ("attributes" in data && data.attributes != undefined) {
                        this.attributes = data.attributes;
                    }
                    if ("dropped_attributes_count" in data && data.dropped_attributes_count != undefined) {
                        this.dropped_attributes_count = data.dropped_attributes_count;
                    }
                }
            }
            get time_unix_nano() {
                return pb_1.Message.getField(this, 1) as number;
            }
            set time_unix_nano(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get name() {
                return pb_1.Message.getField(this, 2) as string;
            }
            set name(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get attributes() {
                return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.KeyValue, 3) as dependency_1.opentelemetry.proto.common.v1.KeyValue[];
            }
            set attributes(value: dependency_1.opentelemetry.proto.common.v1.KeyValue[]) {
                pb_1.Message.setRepeatedWrapperField(this, 3, value);
            }
            get dropped_attributes_count() {
                return pb_1.Message.getField(this, 4) as number;
            }
            set dropped_attributes_count(value: number) {
                pb_1.Message.setField(this, 4, value);
            }
            static fromObject(data: {
                time_unix_nano?: number;
                name?: string;
                attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                dropped_attributes_count?: number;
            }) {
                const message = new Event({});
                if (data.time_unix_nano != null) {
                    message.time_unix_nano = data.time_unix_nano;
                }
                if (data.name != null) {
                    message.name = data.name;
                }
                if (data.attributes != null) {
                    message.attributes = data.attributes.map(item => dependency_1.opentelemetry.proto.common.v1.KeyValue.fromObject(item));
                }
                if (data.dropped_attributes_count != null) {
                    message.dropped_attributes_count = data.dropped_attributes_count;
                }
                return message;
            }
            toObject() {
                const data: {
                    time_unix_nano?: number;
                    name?: string;
                    attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                    dropped_attributes_count?: number;
                } = {};
                if (this.time_unix_nano != null) {
                    data.time_unix_nano = this.time_unix_nano;
                }
                if (this.name != null) {
                    data.name = this.name;
                }
                if (this.attributes != null) {
                    data.attributes = this.attributes.map((item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.toObject());
                }
                if (this.dropped_attributes_count != null) {
                    data.dropped_attributes_count = this.dropped_attributes_count;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.time_unix_nano !== undefined)
                    writer.writeFixed64(1, this.time_unix_nano);
                if (typeof this.name === "string" && this.name.length)
                    writer.writeString(2, this.name);
                if (this.attributes !== undefined)
                    writer.writeRepeatedMessage(3, this.attributes, (item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.serialize(writer));
                if (this.dropped_attributes_count !== undefined)
                    writer.writeUint32(4, this.dropped_attributes_count);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Event {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Event();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.time_unix_nano = reader.readFixed64();
                            break;
                        case 2:
                            message.name = reader.readString();
                            break;
                        case 3:
                            reader.readMessage(message.attributes, () => pb_1.Message.addToRepeatedWrapperField(message, 3, dependency_1.opentelemetry.proto.common.v1.KeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.KeyValue));
                            break;
                        case 4:
                            message.dropped_attributes_count = reader.readUint32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Event {
                return Event.deserialize(bytes);
            }
        }
        export class Link extends pb_1.Message {
            constructor(data?: any[] | {
                trace_id?: Uint8Array;
                span_id?: Uint8Array;
                trace_state?: string;
                attributes?: dependency_1.opentelemetry.proto.common.v1.KeyValue[];
                dropped_attributes_count?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("trace_id" in data && data.trace_id != undefined) {
                        this.trace_id = data.trace_id;
                    }
                    if ("span_id" in data && data.span_id != undefined) {
                        this.span_id = data.span_id;
                    }
                    if ("trace_state" in data && data.trace_state != undefined) {
                        this.trace_state = data.trace_state;
                    }
                    if ("attributes" in data && data.attributes != undefined) {
                        this.attributes = data.attributes;
                    }
                    if ("dropped_attributes_count" in data && data.dropped_attributes_count != undefined) {
                        this.dropped_attributes_count = data.dropped_attributes_count;
                    }
                }
            }
            get trace_id() {
                return pb_1.Message.getField(this, 1) as Uint8Array;
            }
            set trace_id(value: Uint8Array) {
                pb_1.Message.setField(this, 1, value);
            }
            get span_id() {
                return pb_1.Message.getField(this, 2) as Uint8Array;
            }
            set span_id(value: Uint8Array) {
                pb_1.Message.setField(this, 2, value);
            }
            get trace_state() {
                return pb_1.Message.getField(this, 3) as string;
            }
            set trace_state(value: string) {
                pb_1.Message.setField(this, 3, value);
            }
            get attributes() {
                return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.KeyValue, 4) as dependency_1.opentelemetry.proto.common.v1.KeyValue[];
            }
            set attributes(value: dependency_1.opentelemetry.proto.common.v1.KeyValue[]) {
                pb_1.Message.setRepeatedWrapperField(this, 4, value);
            }
            get dropped_attributes_count() {
                return pb_1.Message.getField(this, 5) as number;
            }
            set dropped_attributes_count(value: number) {
                pb_1.Message.setField(this, 5, value);
            }
            static fromObject(data: {
                trace_id?: Uint8Array;
                span_id?: Uint8Array;
                trace_state?: string;
                attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                dropped_attributes_count?: number;
            }) {
                const message = new Link({});
                if (data.trace_id != null) {
                    message.trace_id = data.trace_id;
                }
                if (data.span_id != null) {
                    message.span_id = data.span_id;
                }
                if (data.trace_state != null) {
                    message.trace_state = data.trace_state;
                }
                if (data.attributes != null) {
                    message.attributes = data.attributes.map(item => dependency_1.opentelemetry.proto.common.v1.KeyValue.fromObject(item));
                }
                if (data.dropped_attributes_count != null) {
                    message.dropped_attributes_count = data.dropped_attributes_count;
                }
                return message;
            }
            toObject() {
                const data: {
                    trace_id?: Uint8Array;
                    span_id?: Uint8Array;
                    trace_state?: string;
                    attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                    dropped_attributes_count?: number;
                } = {};
                if (this.trace_id != null) {
                    data.trace_id = this.trace_id;
                }
                if (this.span_id != null) {
                    data.span_id = this.span_id;
                }
                if (this.trace_state != null) {
                    data.trace_state = this.trace_state;
                }
                if (this.attributes != null) {
                    data.attributes = this.attributes.map((item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.toObject());
                }
                if (this.dropped_attributes_count != null) {
                    data.dropped_attributes_count = this.dropped_attributes_count;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.trace_id !== undefined)
                    writer.writeBytes(1, this.trace_id);
                if (this.span_id !== undefined)
                    writer.writeBytes(2, this.span_id);
                if (typeof this.trace_state === "string" && this.trace_state.length)
                    writer.writeString(3, this.trace_state);
                if (this.attributes !== undefined)
                    writer.writeRepeatedMessage(4, this.attributes, (item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.serialize(writer));
                if (this.dropped_attributes_count !== undefined)
                    writer.writeUint32(5, this.dropped_attributes_count);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Link {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Link();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.trace_id = reader.readBytes();
                            break;
                        case 2:
                            message.span_id = reader.readBytes();
                            break;
                        case 3:
                            message.trace_state = reader.readString();
                            break;
                        case 4:
                            reader.readMessage(message.attributes, () => pb_1.Message.addToRepeatedWrapperField(message, 4, dependency_1.opentelemetry.proto.common.v1.KeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.KeyValue));
                            break;
                        case 5:
                            message.dropped_attributes_count = reader.readUint32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Link {
                return Link.deserialize(bytes);
            }
        }
    }
    export class Status extends pb_1.Message {
        constructor(data?: any[] | {
            deprecated_code?: Status.DeprecatedStatusCode;
            message?: string;
            code?: Status.StatusCode;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("deprecated_code" in data && data.deprecated_code != undefined) {
                    this.deprecated_code = data.deprecated_code;
                }
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
                if ("code" in data && data.code != undefined) {
                    this.code = data.code;
                }
            }
        }
        get deprecated_code() {
            return pb_1.Message.getField(this, 1) as Status.DeprecatedStatusCode;
        }
        set deprecated_code(value: Status.DeprecatedStatusCode) {
            pb_1.Message.setField(this, 1, value);
        }
        get message() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get code() {
            return pb_1.Message.getField(this, 3) as Status.StatusCode;
        }
        set code(value: Status.StatusCode) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            deprecated_code?: Status.DeprecatedStatusCode;
            message?: string;
            code?: Status.StatusCode;
        }) {
            const message = new Status({});
            if (data.deprecated_code != null) {
                message.deprecated_code = data.deprecated_code;
            }
            if (data.message != null) {
                message.message = data.message;
            }
            if (data.code != null) {
                message.code = data.code;
            }
            return message;
        }
        toObject() {
            const data: {
                deprecated_code?: Status.DeprecatedStatusCode;
                message?: string;
                code?: Status.StatusCode;
            } = {};
            if (this.deprecated_code != null) {
                data.deprecated_code = this.deprecated_code;
            }
            if (this.message != null) {
                data.message = this.message;
            }
            if (this.code != null) {
                data.code = this.code;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.deprecated_code !== undefined)
                writer.writeEnum(1, this.deprecated_code);
            if (typeof this.message === "string" && this.message.length)
                writer.writeString(2, this.message);
            if (this.code !== undefined)
                writer.writeEnum(3, this.code);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Status {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Status();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.deprecated_code = reader.readEnum();
                        break;
                    case 2:
                        message.message = reader.readString();
                        break;
                    case 3:
                        message.code = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Status {
            return Status.deserialize(bytes);
        }
    }
    export namespace Status {
        export enum DeprecatedStatusCode {
            DEPRECATED_STATUS_CODE_OK = 0,
            DEPRECATED_STATUS_CODE_CANCELLED = 1,
            DEPRECATED_STATUS_CODE_UNKNOWN_ERROR = 2,
            DEPRECATED_STATUS_CODE_INVALID_ARGUMENT = 3,
            DEPRECATED_STATUS_CODE_DEADLINE_EXCEEDED = 4,
            DEPRECATED_STATUS_CODE_NOT_FOUND = 5,
            DEPRECATED_STATUS_CODE_ALREADY_EXISTS = 6,
            DEPRECATED_STATUS_CODE_PERMISSION_DENIED = 7,
            DEPRECATED_STATUS_CODE_RESOURCE_EXHAUSTED = 8,
            DEPRECATED_STATUS_CODE_FAILED_PRECONDITION = 9,
            DEPRECATED_STATUS_CODE_ABORTED = 10,
            DEPRECATED_STATUS_CODE_OUT_OF_RANGE = 11,
            DEPRECATED_STATUS_CODE_UNIMPLEMENTED = 12,
            DEPRECATED_STATUS_CODE_INTERNAL_ERROR = 13,
            DEPRECATED_STATUS_CODE_UNAVAILABLE = 14,
            DEPRECATED_STATUS_CODE_DATA_LOSS = 15,
            DEPRECATED_STATUS_CODE_UNAUTHENTICATED = 16
        }
        export enum StatusCode {
            STATUS_CODE_UNSET = 0,
            STATUS_CODE_OK = 1,
            STATUS_CODE_ERROR = 2
        }
    }
}
