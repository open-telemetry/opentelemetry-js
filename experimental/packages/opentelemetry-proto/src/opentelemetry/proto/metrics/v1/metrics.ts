/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.15.6
 * source: opentelemetry/proto/metrics/v1/metrics.proto
 * git: https://github.com/thesayyn/protoc-gen-ts
 *  */
import * as dependency_1 from "./../../common/v1/common";
import * as dependency_2 from "./../../resource/v1/resource";
import * as pb_1 from "google-protobuf";
export namespace opentelemetry.proto.metrics.v1 {
    export enum AggregationTemporality {
        AGGREGATION_TEMPORALITY_UNSPECIFIED = 0,
        AGGREGATION_TEMPORALITY_DELTA = 1,
        AGGREGATION_TEMPORALITY_CUMULATIVE = 2
    }
    export enum DataPointFlags {
        FLAG_NONE = 0,
        FLAG_NO_RECORDED_VALUE = 1
    }
    export class MetricsData extends pb_1.Message {
        constructor(data?: any[] | {
            resource_metrics?: ResourceMetrics[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("resource_metrics" in data && data.resource_metrics != undefined) {
                    this.resource_metrics = data.resource_metrics;
                }
            }
        }
        get resource_metrics() {
            return pb_1.Message.getRepeatedWrapperField(this, ResourceMetrics, 1) as ResourceMetrics[];
        }
        set resource_metrics(value: ResourceMetrics[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            resource_metrics?: ReturnType<typeof ResourceMetrics.prototype.toObject>[];
        }) {
            const message = new MetricsData({});
            if (data.resource_metrics != null) {
                message.resource_metrics = data.resource_metrics.map(item => ResourceMetrics.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                resource_metrics?: ReturnType<typeof ResourceMetrics.prototype.toObject>[];
            } = {};
            if (this.resource_metrics != null) {
                data.resource_metrics = this.resource_metrics.map((item: ResourceMetrics) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.resource_metrics !== undefined)
                writer.writeRepeatedMessage(1, this.resource_metrics, (item: ResourceMetrics) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MetricsData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MetricsData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.resource_metrics, () => pb_1.Message.addToRepeatedWrapperField(message, 1, ResourceMetrics.deserialize(reader), ResourceMetrics));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MetricsData {
            return MetricsData.deserialize(bytes);
        }
    }
    export class ResourceMetrics extends pb_1.Message {
        constructor(data?: any[] | {
            resource?: dependency_2.opentelemetry.proto.resource.v1.Resource;
            instrumentation_library_metrics?: InstrumentationLibraryMetrics[];
            schema_url?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("resource" in data && data.resource != undefined) {
                    this.resource = data.resource;
                }
                if ("instrumentation_library_metrics" in data && data.instrumentation_library_metrics != undefined) {
                    this.instrumentation_library_metrics = data.instrumentation_library_metrics;
                }
                if ("schema_url" in data && data.schema_url != undefined) {
                    this.schema_url = data.schema_url;
                }
            }
        }
        get resource() {
            return pb_1.Message.getWrapperField(this, dependency_2.opentelemetry.proto.resource.v1.Resource, 1) as dependency_2.opentelemetry.proto.resource.v1.Resource;
        }
        set resource(value: dependency_2.opentelemetry.proto.resource.v1.Resource) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get instrumentation_library_metrics() {
            return pb_1.Message.getRepeatedWrapperField(this, InstrumentationLibraryMetrics, 2) as InstrumentationLibraryMetrics[];
        }
        set instrumentation_library_metrics(value: InstrumentationLibraryMetrics[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get schema_url() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set schema_url(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            resource?: ReturnType<typeof dependency_2.opentelemetry.proto.resource.v1.Resource.prototype.toObject>;
            instrumentation_library_metrics?: ReturnType<typeof InstrumentationLibraryMetrics.prototype.toObject>[];
            schema_url?: string;
        }) {
            const message = new ResourceMetrics({});
            if (data.resource != null) {
                message.resource = dependency_2.opentelemetry.proto.resource.v1.Resource.fromObject(data.resource);
            }
            if (data.instrumentation_library_metrics != null) {
                message.instrumentation_library_metrics = data.instrumentation_library_metrics.map(item => InstrumentationLibraryMetrics.fromObject(item));
            }
            if (data.schema_url != null) {
                message.schema_url = data.schema_url;
            }
            return message;
        }
        toObject() {
            const data: {
                resource?: ReturnType<typeof dependency_2.opentelemetry.proto.resource.v1.Resource.prototype.toObject>;
                instrumentation_library_metrics?: ReturnType<typeof InstrumentationLibraryMetrics.prototype.toObject>[];
                schema_url?: string;
            } = {};
            if (this.resource != null) {
                data.resource = this.resource.toObject();
            }
            if (this.instrumentation_library_metrics != null) {
                data.instrumentation_library_metrics = this.instrumentation_library_metrics.map((item: InstrumentationLibraryMetrics) => item.toObject());
            }
            if (this.schema_url != null) {
                data.schema_url = this.schema_url;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.resource !== undefined)
                writer.writeMessage(1, this.resource, () => this.resource.serialize(writer));
            if (this.instrumentation_library_metrics !== undefined)
                writer.writeRepeatedMessage(2, this.instrumentation_library_metrics, (item: InstrumentationLibraryMetrics) => item.serialize(writer));
            if (typeof this.schema_url === "string" && this.schema_url.length)
                writer.writeString(3, this.schema_url);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ResourceMetrics {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ResourceMetrics();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.resource, () => message.resource = dependency_2.opentelemetry.proto.resource.v1.Resource.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.instrumentation_library_metrics, () => pb_1.Message.addToRepeatedWrapperField(message, 2, InstrumentationLibraryMetrics.deserialize(reader), InstrumentationLibraryMetrics));
                        break;
                    case 3:
                        message.schema_url = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ResourceMetrics {
            return ResourceMetrics.deserialize(bytes);
        }
    }
    export class InstrumentationLibraryMetrics extends pb_1.Message {
        constructor(data?: any[] | {
            instrumentation_library?: dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary;
            metrics?: Metric[];
            schema_url?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("instrumentation_library" in data && data.instrumentation_library != undefined) {
                    this.instrumentation_library = data.instrumentation_library;
                }
                if ("metrics" in data && data.metrics != undefined) {
                    this.metrics = data.metrics;
                }
                if ("schema_url" in data && data.schema_url != undefined) {
                    this.schema_url = data.schema_url;
                }
            }
        }
        get instrumentation_library() {
            return pb_1.Message.getWrapperField(this, dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary, 1) as dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary;
        }
        set instrumentation_library(value: dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get metrics() {
            return pb_1.Message.getRepeatedWrapperField(this, Metric, 2) as Metric[];
        }
        set metrics(value: Metric[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get schema_url() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set schema_url(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            instrumentation_library?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary.prototype.toObject>;
            metrics?: ReturnType<typeof Metric.prototype.toObject>[];
            schema_url?: string;
        }) {
            const message = new InstrumentationLibraryMetrics({});
            if (data.instrumentation_library != null) {
                message.instrumentation_library = dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary.fromObject(data.instrumentation_library);
            }
            if (data.metrics != null) {
                message.metrics = data.metrics.map(item => Metric.fromObject(item));
            }
            if (data.schema_url != null) {
                message.schema_url = data.schema_url;
            }
            return message;
        }
        toObject() {
            const data: {
                instrumentation_library?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary.prototype.toObject>;
                metrics?: ReturnType<typeof Metric.prototype.toObject>[];
                schema_url?: string;
            } = {};
            if (this.instrumentation_library != null) {
                data.instrumentation_library = this.instrumentation_library.toObject();
            }
            if (this.metrics != null) {
                data.metrics = this.metrics.map((item: Metric) => item.toObject());
            }
            if (this.schema_url != null) {
                data.schema_url = this.schema_url;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.instrumentation_library !== undefined)
                writer.writeMessage(1, this.instrumentation_library, () => this.instrumentation_library.serialize(writer));
            if (this.metrics !== undefined)
                writer.writeRepeatedMessage(2, this.metrics, (item: Metric) => item.serialize(writer));
            if (typeof this.schema_url === "string" && this.schema_url.length)
                writer.writeString(3, this.schema_url);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): InstrumentationLibraryMetrics {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new InstrumentationLibraryMetrics();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.instrumentation_library, () => message.instrumentation_library = dependency_1.opentelemetry.proto.common.v1.InstrumentationLibrary.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.metrics, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Metric.deserialize(reader), Metric));
                        break;
                    case 3:
                        message.schema_url = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): InstrumentationLibraryMetrics {
            return InstrumentationLibraryMetrics.deserialize(bytes);
        }
    }
    export class Metric extends pb_1.Message {
        constructor(data?: any[] | ({
            name?: string;
            description?: string;
            unit?: string;
        } & (({
            int_gauge?: IntGauge;
            gauge?: never;
            int_sum?: never;
            sum?: never;
            int_histogram?: never;
            histogram?: never;
            exponential_histogram?: never;
            summary?: never;
        } | {
            int_gauge?: never;
            gauge?: Gauge;
            int_sum?: never;
            sum?: never;
            int_histogram?: never;
            histogram?: never;
            exponential_histogram?: never;
            summary?: never;
        } | {
            int_gauge?: never;
            gauge?: never;
            int_sum?: IntSum;
            sum?: never;
            int_histogram?: never;
            histogram?: never;
            exponential_histogram?: never;
            summary?: never;
        } | {
            int_gauge?: never;
            gauge?: never;
            int_sum?: never;
            sum?: Sum;
            int_histogram?: never;
            histogram?: never;
            exponential_histogram?: never;
            summary?: never;
        } | {
            int_gauge?: never;
            gauge?: never;
            int_sum?: never;
            sum?: never;
            int_histogram?: IntHistogram;
            histogram?: never;
            exponential_histogram?: never;
            summary?: never;
        } | {
            int_gauge?: never;
            gauge?: never;
            int_sum?: never;
            sum?: never;
            int_histogram?: never;
            histogram?: Histogram;
            exponential_histogram?: never;
            summary?: never;
        } | {
            int_gauge?: never;
            gauge?: never;
            int_sum?: never;
            sum?: never;
            int_histogram?: never;
            histogram?: never;
            exponential_histogram?: ExponentialHistogram;
            summary?: never;
        } | {
            int_gauge?: never;
            gauge?: never;
            int_sum?: never;
            sum?: never;
            int_histogram?: never;
            histogram?: never;
            exponential_histogram?: never;
            summary?: Summary;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[4, 5, 6, 7, 8, 9, 10, 11]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
                if ("unit" in data && data.unit != undefined) {
                    this.unit = data.unit;
                }
                if ("int_gauge" in data && data.int_gauge != undefined) {
                    this.int_gauge = data.int_gauge;
                }
                if ("gauge" in data && data.gauge != undefined) {
                    this.gauge = data.gauge;
                }
                if ("int_sum" in data && data.int_sum != undefined) {
                    this.int_sum = data.int_sum;
                }
                if ("sum" in data && data.sum != undefined) {
                    this.sum = data.sum;
                }
                if ("int_histogram" in data && data.int_histogram != undefined) {
                    this.int_histogram = data.int_histogram;
                }
                if ("histogram" in data && data.histogram != undefined) {
                    this.histogram = data.histogram;
                }
                if ("exponential_histogram" in data && data.exponential_histogram != undefined) {
                    this.exponential_histogram = data.exponential_histogram;
                }
                if ("summary" in data && data.summary != undefined) {
                    this.summary = data.summary;
                }
            }
        }
        get name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get description() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set description(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get unit() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set unit(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get int_gauge() {
            return pb_1.Message.getWrapperField(this, IntGauge, 4) as IntGauge;
        }
        set int_gauge(value: IntGauge) {
            pb_1.Message.setOneofWrapperField(this, 4, [4, 5, 6, 7, 8, 9, 10, 11], value);
        }
        get gauge() {
            return pb_1.Message.getWrapperField(this, Gauge, 5) as Gauge;
        }
        set gauge(value: Gauge) {
            pb_1.Message.setOneofWrapperField(this, 5, [4, 5, 6, 7, 8, 9, 10, 11], value);
        }
        get int_sum() {
            return pb_1.Message.getWrapperField(this, IntSum, 6) as IntSum;
        }
        set int_sum(value: IntSum) {
            pb_1.Message.setOneofWrapperField(this, 6, [4, 5, 6, 7, 8, 9, 10, 11], value);
        }
        get sum() {
            return pb_1.Message.getWrapperField(this, Sum, 7) as Sum;
        }
        set sum(value: Sum) {
            pb_1.Message.setOneofWrapperField(this, 7, [4, 5, 6, 7, 8, 9, 10, 11], value);
        }
        get int_histogram() {
            return pb_1.Message.getWrapperField(this, IntHistogram, 8) as IntHistogram;
        }
        set int_histogram(value: IntHistogram) {
            pb_1.Message.setOneofWrapperField(this, 8, [4, 5, 6, 7, 8, 9, 10, 11], value);
        }
        get histogram() {
            return pb_1.Message.getWrapperField(this, Histogram, 9) as Histogram;
        }
        set histogram(value: Histogram) {
            pb_1.Message.setOneofWrapperField(this, 9, [4, 5, 6, 7, 8, 9, 10, 11], value);
        }
        get exponential_histogram() {
            return pb_1.Message.getWrapperField(this, ExponentialHistogram, 10) as ExponentialHistogram;
        }
        set exponential_histogram(value: ExponentialHistogram) {
            pb_1.Message.setOneofWrapperField(this, 10, [4, 5, 6, 7, 8, 9, 10, 11], value);
        }
        get summary() {
            return pb_1.Message.getWrapperField(this, Summary, 11) as Summary;
        }
        set summary(value: Summary) {
            pb_1.Message.setOneofWrapperField(this, 11, [4, 5, 6, 7, 8, 9, 10, 11], value);
        }
        get data() {
            const cases: {
                [index: number]: "none" | "int_gauge" | "gauge" | "int_sum" | "sum" | "int_histogram" | "histogram" | "exponential_histogram" | "summary";
            } = {
                0: "none",
                4: "int_gauge",
                5: "gauge",
                6: "int_sum",
                7: "sum",
                8: "int_histogram",
                9: "histogram",
                10: "exponential_histogram",
                11: "summary"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4, 5, 6, 7, 8, 9, 10, 11])];
        }
        static fromObject(data: {
            name?: string;
            description?: string;
            unit?: string;
            int_gauge?: ReturnType<typeof IntGauge.prototype.toObject>;
            gauge?: ReturnType<typeof Gauge.prototype.toObject>;
            int_sum?: ReturnType<typeof IntSum.prototype.toObject>;
            sum?: ReturnType<typeof Sum.prototype.toObject>;
            int_histogram?: ReturnType<typeof IntHistogram.prototype.toObject>;
            histogram?: ReturnType<typeof Histogram.prototype.toObject>;
            exponential_histogram?: ReturnType<typeof ExponentialHistogram.prototype.toObject>;
            summary?: ReturnType<typeof Summary.prototype.toObject>;
        }) {
            const message = new Metric({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.description != null) {
                message.description = data.description;
            }
            if (data.unit != null) {
                message.unit = data.unit;
            }
            if (data.int_gauge != null) {
                message.int_gauge = IntGauge.fromObject(data.int_gauge);
            }
            if (data.gauge != null) {
                message.gauge = Gauge.fromObject(data.gauge);
            }
            if (data.int_sum != null) {
                message.int_sum = IntSum.fromObject(data.int_sum);
            }
            if (data.sum != null) {
                message.sum = Sum.fromObject(data.sum);
            }
            if (data.int_histogram != null) {
                message.int_histogram = IntHistogram.fromObject(data.int_histogram);
            }
            if (data.histogram != null) {
                message.histogram = Histogram.fromObject(data.histogram);
            }
            if (data.exponential_histogram != null) {
                message.exponential_histogram = ExponentialHistogram.fromObject(data.exponential_histogram);
            }
            if (data.summary != null) {
                message.summary = Summary.fromObject(data.summary);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                description?: string;
                unit?: string;
                int_gauge?: ReturnType<typeof IntGauge.prototype.toObject>;
                gauge?: ReturnType<typeof Gauge.prototype.toObject>;
                int_sum?: ReturnType<typeof IntSum.prototype.toObject>;
                sum?: ReturnType<typeof Sum.prototype.toObject>;
                int_histogram?: ReturnType<typeof IntHistogram.prototype.toObject>;
                histogram?: ReturnType<typeof Histogram.prototype.toObject>;
                exponential_histogram?: ReturnType<typeof ExponentialHistogram.prototype.toObject>;
                summary?: ReturnType<typeof Summary.prototype.toObject>;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.description != null) {
                data.description = this.description;
            }
            if (this.unit != null) {
                data.unit = this.unit;
            }
            if (this.int_gauge != null) {
                data.int_gauge = this.int_gauge.toObject();
            }
            if (this.gauge != null) {
                data.gauge = this.gauge.toObject();
            }
            if (this.int_sum != null) {
                data.int_sum = this.int_sum.toObject();
            }
            if (this.sum != null) {
                data.sum = this.sum.toObject();
            }
            if (this.int_histogram != null) {
                data.int_histogram = this.int_histogram.toObject();
            }
            if (this.histogram != null) {
                data.histogram = this.histogram.toObject();
            }
            if (this.exponential_histogram != null) {
                data.exponential_histogram = this.exponential_histogram.toObject();
            }
            if (this.summary != null) {
                data.summary = this.summary.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.name === "string" && this.name.length)
                writer.writeString(1, this.name);
            if (typeof this.description === "string" && this.description.length)
                writer.writeString(2, this.description);
            if (typeof this.unit === "string" && this.unit.length)
                writer.writeString(3, this.unit);
            if (this.int_gauge !== undefined)
                writer.writeMessage(4, this.int_gauge, () => this.int_gauge.serialize(writer));
            if (this.gauge !== undefined)
                writer.writeMessage(5, this.gauge, () => this.gauge.serialize(writer));
            if (this.int_sum !== undefined)
                writer.writeMessage(6, this.int_sum, () => this.int_sum.serialize(writer));
            if (this.sum !== undefined)
                writer.writeMessage(7, this.sum, () => this.sum.serialize(writer));
            if (this.int_histogram !== undefined)
                writer.writeMessage(8, this.int_histogram, () => this.int_histogram.serialize(writer));
            if (this.histogram !== undefined)
                writer.writeMessage(9, this.histogram, () => this.histogram.serialize(writer));
            if (this.exponential_histogram !== undefined)
                writer.writeMessage(10, this.exponential_histogram, () => this.exponential_histogram.serialize(writer));
            if (this.summary !== undefined)
                writer.writeMessage(11, this.summary, () => this.summary.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Metric {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Metric();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.description = reader.readString();
                        break;
                    case 3:
                        message.unit = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message.int_gauge, () => message.int_gauge = IntGauge.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.gauge, () => message.gauge = Gauge.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.int_sum, () => message.int_sum = IntSum.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.sum, () => message.sum = Sum.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.int_histogram, () => message.int_histogram = IntHistogram.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.histogram, () => message.histogram = Histogram.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.exponential_histogram, () => message.exponential_histogram = ExponentialHistogram.deserialize(reader));
                        break;
                    case 11:
                        reader.readMessage(message.summary, () => message.summary = Summary.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Metric {
            return Metric.deserialize(bytes);
        }
    }
    export class Gauge extends pb_1.Message {
        constructor(data?: any[] | {
            data_points?: NumberDataPoint[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data_points" in data && data.data_points != undefined) {
                    this.data_points = data.data_points;
                }
            }
        }
        get data_points() {
            return pb_1.Message.getRepeatedWrapperField(this, NumberDataPoint, 1) as NumberDataPoint[];
        }
        set data_points(value: NumberDataPoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            data_points?: ReturnType<typeof NumberDataPoint.prototype.toObject>[];
        }) {
            const message = new Gauge({});
            if (data.data_points != null) {
                message.data_points = data.data_points.map(item => NumberDataPoint.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                data_points?: ReturnType<typeof NumberDataPoint.prototype.toObject>[];
            } = {};
            if (this.data_points != null) {
                data.data_points = this.data_points.map((item: NumberDataPoint) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data_points !== undefined)
                writer.writeRepeatedMessage(1, this.data_points, (item: NumberDataPoint) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Gauge {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Gauge();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data_points, () => pb_1.Message.addToRepeatedWrapperField(message, 1, NumberDataPoint.deserialize(reader), NumberDataPoint));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Gauge {
            return Gauge.deserialize(bytes);
        }
    }
    export class Sum extends pb_1.Message {
        constructor(data?: any[] | {
            data_points?: NumberDataPoint[];
            aggregation_temporality?: AggregationTemporality;
            is_monotonic?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data_points" in data && data.data_points != undefined) {
                    this.data_points = data.data_points;
                }
                if ("aggregation_temporality" in data && data.aggregation_temporality != undefined) {
                    this.aggregation_temporality = data.aggregation_temporality;
                }
                if ("is_monotonic" in data && data.is_monotonic != undefined) {
                    this.is_monotonic = data.is_monotonic;
                }
            }
        }
        get data_points() {
            return pb_1.Message.getRepeatedWrapperField(this, NumberDataPoint, 1) as NumberDataPoint[];
        }
        set data_points(value: NumberDataPoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get aggregation_temporality() {
            return pb_1.Message.getField(this, 2) as AggregationTemporality;
        }
        set aggregation_temporality(value: AggregationTemporality) {
            pb_1.Message.setField(this, 2, value);
        }
        get is_monotonic() {
            return pb_1.Message.getField(this, 3) as boolean;
        }
        set is_monotonic(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            data_points?: ReturnType<typeof NumberDataPoint.prototype.toObject>[];
            aggregation_temporality?: AggregationTemporality;
            is_monotonic?: boolean;
        }) {
            const message = new Sum({});
            if (data.data_points != null) {
                message.data_points = data.data_points.map(item => NumberDataPoint.fromObject(item));
            }
            if (data.aggregation_temporality != null) {
                message.aggregation_temporality = data.aggregation_temporality;
            }
            if (data.is_monotonic != null) {
                message.is_monotonic = data.is_monotonic;
            }
            return message;
        }
        toObject() {
            const data: {
                data_points?: ReturnType<typeof NumberDataPoint.prototype.toObject>[];
                aggregation_temporality?: AggregationTemporality;
                is_monotonic?: boolean;
            } = {};
            if (this.data_points != null) {
                data.data_points = this.data_points.map((item: NumberDataPoint) => item.toObject());
            }
            if (this.aggregation_temporality != null) {
                data.aggregation_temporality = this.aggregation_temporality;
            }
            if (this.is_monotonic != null) {
                data.is_monotonic = this.is_monotonic;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data_points !== undefined)
                writer.writeRepeatedMessage(1, this.data_points, (item: NumberDataPoint) => item.serialize(writer));
            if (this.aggregation_temporality !== undefined)
                writer.writeEnum(2, this.aggregation_temporality);
            if (this.is_monotonic !== undefined)
                writer.writeBool(3, this.is_monotonic);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Sum {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Sum();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data_points, () => pb_1.Message.addToRepeatedWrapperField(message, 1, NumberDataPoint.deserialize(reader), NumberDataPoint));
                        break;
                    case 2:
                        message.aggregation_temporality = reader.readEnum();
                        break;
                    case 3:
                        message.is_monotonic = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Sum {
            return Sum.deserialize(bytes);
        }
    }
    export class Histogram extends pb_1.Message {
        constructor(data?: any[] | {
            data_points?: HistogramDataPoint[];
            aggregation_temporality?: AggregationTemporality;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data_points" in data && data.data_points != undefined) {
                    this.data_points = data.data_points;
                }
                if ("aggregation_temporality" in data && data.aggregation_temporality != undefined) {
                    this.aggregation_temporality = data.aggregation_temporality;
                }
            }
        }
        get data_points() {
            return pb_1.Message.getRepeatedWrapperField(this, HistogramDataPoint, 1) as HistogramDataPoint[];
        }
        set data_points(value: HistogramDataPoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get aggregation_temporality() {
            return pb_1.Message.getField(this, 2) as AggregationTemporality;
        }
        set aggregation_temporality(value: AggregationTemporality) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            data_points?: ReturnType<typeof HistogramDataPoint.prototype.toObject>[];
            aggregation_temporality?: AggregationTemporality;
        }) {
            const message = new Histogram({});
            if (data.data_points != null) {
                message.data_points = data.data_points.map(item => HistogramDataPoint.fromObject(item));
            }
            if (data.aggregation_temporality != null) {
                message.aggregation_temporality = data.aggregation_temporality;
            }
            return message;
        }
        toObject() {
            const data: {
                data_points?: ReturnType<typeof HistogramDataPoint.prototype.toObject>[];
                aggregation_temporality?: AggregationTemporality;
            } = {};
            if (this.data_points != null) {
                data.data_points = this.data_points.map((item: HistogramDataPoint) => item.toObject());
            }
            if (this.aggregation_temporality != null) {
                data.aggregation_temporality = this.aggregation_temporality;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data_points !== undefined)
                writer.writeRepeatedMessage(1, this.data_points, (item: HistogramDataPoint) => item.serialize(writer));
            if (this.aggregation_temporality !== undefined)
                writer.writeEnum(2, this.aggregation_temporality);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Histogram {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Histogram();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data_points, () => pb_1.Message.addToRepeatedWrapperField(message, 1, HistogramDataPoint.deserialize(reader), HistogramDataPoint));
                        break;
                    case 2:
                        message.aggregation_temporality = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Histogram {
            return Histogram.deserialize(bytes);
        }
    }
    export class ExponentialHistogram extends pb_1.Message {
        constructor(data?: any[] | {
            data_points?: ExponentialHistogramDataPoint[];
            aggregation_temporality?: AggregationTemporality;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data_points" in data && data.data_points != undefined) {
                    this.data_points = data.data_points;
                }
                if ("aggregation_temporality" in data && data.aggregation_temporality != undefined) {
                    this.aggregation_temporality = data.aggregation_temporality;
                }
            }
        }
        get data_points() {
            return pb_1.Message.getRepeatedWrapperField(this, ExponentialHistogramDataPoint, 1) as ExponentialHistogramDataPoint[];
        }
        set data_points(value: ExponentialHistogramDataPoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get aggregation_temporality() {
            return pb_1.Message.getField(this, 2) as AggregationTemporality;
        }
        set aggregation_temporality(value: AggregationTemporality) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            data_points?: ReturnType<typeof ExponentialHistogramDataPoint.prototype.toObject>[];
            aggregation_temporality?: AggregationTemporality;
        }) {
            const message = new ExponentialHistogram({});
            if (data.data_points != null) {
                message.data_points = data.data_points.map(item => ExponentialHistogramDataPoint.fromObject(item));
            }
            if (data.aggregation_temporality != null) {
                message.aggregation_temporality = data.aggregation_temporality;
            }
            return message;
        }
        toObject() {
            const data: {
                data_points?: ReturnType<typeof ExponentialHistogramDataPoint.prototype.toObject>[];
                aggregation_temporality?: AggregationTemporality;
            } = {};
            if (this.data_points != null) {
                data.data_points = this.data_points.map((item: ExponentialHistogramDataPoint) => item.toObject());
            }
            if (this.aggregation_temporality != null) {
                data.aggregation_temporality = this.aggregation_temporality;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data_points !== undefined)
                writer.writeRepeatedMessage(1, this.data_points, (item: ExponentialHistogramDataPoint) => item.serialize(writer));
            if (this.aggregation_temporality !== undefined)
                writer.writeEnum(2, this.aggregation_temporality);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExponentialHistogram {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExponentialHistogram();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data_points, () => pb_1.Message.addToRepeatedWrapperField(message, 1, ExponentialHistogramDataPoint.deserialize(reader), ExponentialHistogramDataPoint));
                        break;
                    case 2:
                        message.aggregation_temporality = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ExponentialHistogram {
            return ExponentialHistogram.deserialize(bytes);
        }
    }
    export class Summary extends pb_1.Message {
        constructor(data?: any[] | {
            data_points?: SummaryDataPoint[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data_points" in data && data.data_points != undefined) {
                    this.data_points = data.data_points;
                }
            }
        }
        get data_points() {
            return pb_1.Message.getRepeatedWrapperField(this, SummaryDataPoint, 1) as SummaryDataPoint[];
        }
        set data_points(value: SummaryDataPoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            data_points?: ReturnType<typeof SummaryDataPoint.prototype.toObject>[];
        }) {
            const message = new Summary({});
            if (data.data_points != null) {
                message.data_points = data.data_points.map(item => SummaryDataPoint.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                data_points?: ReturnType<typeof SummaryDataPoint.prototype.toObject>[];
            } = {};
            if (this.data_points != null) {
                data.data_points = this.data_points.map((item: SummaryDataPoint) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data_points !== undefined)
                writer.writeRepeatedMessage(1, this.data_points, (item: SummaryDataPoint) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Summary {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Summary();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data_points, () => pb_1.Message.addToRepeatedWrapperField(message, 1, SummaryDataPoint.deserialize(reader), SummaryDataPoint));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Summary {
            return Summary.deserialize(bytes);
        }
    }
    export class NumberDataPoint extends pb_1.Message {
        constructor(data?: any[] | ({
            attributes?: dependency_1.opentelemetry.proto.common.v1.KeyValue[];
            labels?: dependency_1.opentelemetry.proto.common.v1.StringKeyValue[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            exemplars?: Exemplar[];
            flags?: number;
        } & (({
            as_double?: number;
            as_int?: never;
        } | {
            as_double?: never;
            as_int?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [7, 1, 5], [[4, 6]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("attributes" in data && data.attributes != undefined) {
                    this.attributes = data.attributes;
                }
                if ("labels" in data && data.labels != undefined) {
                    this.labels = data.labels;
                }
                if ("start_time_unix_nano" in data && data.start_time_unix_nano != undefined) {
                    this.start_time_unix_nano = data.start_time_unix_nano;
                }
                if ("time_unix_nano" in data && data.time_unix_nano != undefined) {
                    this.time_unix_nano = data.time_unix_nano;
                }
                if ("as_double" in data && data.as_double != undefined) {
                    this.as_double = data.as_double;
                }
                if ("as_int" in data && data.as_int != undefined) {
                    this.as_int = data.as_int;
                }
                if ("exemplars" in data && data.exemplars != undefined) {
                    this.exemplars = data.exemplars;
                }
                if ("flags" in data && data.flags != undefined) {
                    this.flags = data.flags;
                }
            }
        }
        get attributes() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.KeyValue, 7) as dependency_1.opentelemetry.proto.common.v1.KeyValue[];
        }
        set attributes(value: dependency_1.opentelemetry.proto.common.v1.KeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 7, value);
        }
        get labels() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.StringKeyValue, 1) as dependency_1.opentelemetry.proto.common.v1.StringKeyValue[];
        }
        set labels(value: dependency_1.opentelemetry.proto.common.v1.StringKeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get start_time_unix_nano() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set start_time_unix_nano(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get time_unix_nano() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set time_unix_nano(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get as_double() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set as_double(value: number) {
            pb_1.Message.setOneofField(this, 4, [4, 6], value);
        }
        get as_int() {
            return pb_1.Message.getField(this, 6) as number;
        }
        set as_int(value: number) {
            pb_1.Message.setOneofField(this, 6, [4, 6], value);
        }
        get exemplars() {
            return pb_1.Message.getRepeatedWrapperField(this, Exemplar, 5) as Exemplar[];
        }
        set exemplars(value: Exemplar[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get flags() {
            return pb_1.Message.getField(this, 8) as number;
        }
        set flags(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get value() {
            const cases: {
                [index: number]: "none" | "as_double" | "as_int";
            } = {
                0: "none",
                4: "as_double",
                6: "as_int"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4, 6])];
        }
        static fromObject(data: {
            attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
            labels?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.StringKeyValue.prototype.toObject>[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            as_double?: number;
            as_int?: number;
            exemplars?: ReturnType<typeof Exemplar.prototype.toObject>[];
            flags?: number;
        }) {
            const message = new NumberDataPoint({});
            if (data.attributes != null) {
                message.attributes = data.attributes.map(item => dependency_1.opentelemetry.proto.common.v1.KeyValue.fromObject(item));
            }
            if (data.labels != null) {
                message.labels = data.labels.map(item => dependency_1.opentelemetry.proto.common.v1.StringKeyValue.fromObject(item));
            }
            if (data.start_time_unix_nano != null) {
                message.start_time_unix_nano = data.start_time_unix_nano;
            }
            if (data.time_unix_nano != null) {
                message.time_unix_nano = data.time_unix_nano;
            }
            if (data.as_double != null) {
                message.as_double = data.as_double;
            }
            if (data.as_int != null) {
                message.as_int = data.as_int;
            }
            if (data.exemplars != null) {
                message.exemplars = data.exemplars.map(item => Exemplar.fromObject(item));
            }
            if (data.flags != null) {
                message.flags = data.flags;
            }
            return message;
        }
        toObject() {
            const data: {
                attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                labels?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.StringKeyValue.prototype.toObject>[];
                start_time_unix_nano?: number;
                time_unix_nano?: number;
                as_double?: number;
                as_int?: number;
                exemplars?: ReturnType<typeof Exemplar.prototype.toObject>[];
                flags?: number;
            } = {};
            if (this.attributes != null) {
                data.attributes = this.attributes.map((item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.toObject());
            }
            if (this.labels != null) {
                data.labels = this.labels.map((item: dependency_1.opentelemetry.proto.common.v1.StringKeyValue) => item.toObject());
            }
            if (this.start_time_unix_nano != null) {
                data.start_time_unix_nano = this.start_time_unix_nano;
            }
            if (this.time_unix_nano != null) {
                data.time_unix_nano = this.time_unix_nano;
            }
            if (this.as_double != null) {
                data.as_double = this.as_double;
            }
            if (this.as_int != null) {
                data.as_int = this.as_int;
            }
            if (this.exemplars != null) {
                data.exemplars = this.exemplars.map((item: Exemplar) => item.toObject());
            }
            if (this.flags != null) {
                data.flags = this.flags;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.attributes !== undefined)
                writer.writeRepeatedMessage(7, this.attributes, (item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.serialize(writer));
            if (this.labels !== undefined)
                writer.writeRepeatedMessage(1, this.labels, (item: dependency_1.opentelemetry.proto.common.v1.StringKeyValue) => item.serialize(writer));
            if (this.start_time_unix_nano !== undefined)
                writer.writeFixed64(2, this.start_time_unix_nano);
            if (this.time_unix_nano !== undefined)
                writer.writeFixed64(3, this.time_unix_nano);
            if (this.as_double !== undefined)
                writer.writeDouble(4, this.as_double);
            if (this.as_int !== undefined)
                writer.writeSfixed64(6, this.as_int);
            if (this.exemplars !== undefined)
                writer.writeRepeatedMessage(5, this.exemplars, (item: Exemplar) => item.serialize(writer));
            if (this.flags !== undefined)
                writer.writeUint32(8, this.flags);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): NumberDataPoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new NumberDataPoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 7:
                        reader.readMessage(message.attributes, () => pb_1.Message.addToRepeatedWrapperField(message, 7, dependency_1.opentelemetry.proto.common.v1.KeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.KeyValue));
                        break;
                    case 1:
                        reader.readMessage(message.labels, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_1.opentelemetry.proto.common.v1.StringKeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.StringKeyValue));
                        break;
                    case 2:
                        message.start_time_unix_nano = reader.readFixed64();
                        break;
                    case 3:
                        message.time_unix_nano = reader.readFixed64();
                        break;
                    case 4:
                        message.as_double = reader.readDouble();
                        break;
                    case 6:
                        message.as_int = reader.readSfixed64();
                        break;
                    case 5:
                        reader.readMessage(message.exemplars, () => pb_1.Message.addToRepeatedWrapperField(message, 5, Exemplar.deserialize(reader), Exemplar));
                        break;
                    case 8:
                        message.flags = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): NumberDataPoint {
            return NumberDataPoint.deserialize(bytes);
        }
    }
    export class HistogramDataPoint extends pb_1.Message {
        constructor(data?: any[] | {
            attributes?: dependency_1.opentelemetry.proto.common.v1.KeyValue[];
            labels?: dependency_1.opentelemetry.proto.common.v1.StringKeyValue[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            count?: number;
            sum?: number;
            bucket_counts?: number[];
            explicit_bounds?: number[];
            exemplars?: Exemplar[];
            flags?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [9, 1, 6, 7, 8], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("attributes" in data && data.attributes != undefined) {
                    this.attributes = data.attributes;
                }
                if ("labels" in data && data.labels != undefined) {
                    this.labels = data.labels;
                }
                if ("start_time_unix_nano" in data && data.start_time_unix_nano != undefined) {
                    this.start_time_unix_nano = data.start_time_unix_nano;
                }
                if ("time_unix_nano" in data && data.time_unix_nano != undefined) {
                    this.time_unix_nano = data.time_unix_nano;
                }
                if ("count" in data && data.count != undefined) {
                    this.count = data.count;
                }
                if ("sum" in data && data.sum != undefined) {
                    this.sum = data.sum;
                }
                if ("bucket_counts" in data && data.bucket_counts != undefined) {
                    this.bucket_counts = data.bucket_counts;
                }
                if ("explicit_bounds" in data && data.explicit_bounds != undefined) {
                    this.explicit_bounds = data.explicit_bounds;
                }
                if ("exemplars" in data && data.exemplars != undefined) {
                    this.exemplars = data.exemplars;
                }
                if ("flags" in data && data.flags != undefined) {
                    this.flags = data.flags;
                }
            }
        }
        get attributes() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.KeyValue, 9) as dependency_1.opentelemetry.proto.common.v1.KeyValue[];
        }
        set attributes(value: dependency_1.opentelemetry.proto.common.v1.KeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 9, value);
        }
        get labels() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.StringKeyValue, 1) as dependency_1.opentelemetry.proto.common.v1.StringKeyValue[];
        }
        set labels(value: dependency_1.opentelemetry.proto.common.v1.StringKeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get start_time_unix_nano() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set start_time_unix_nano(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get time_unix_nano() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set time_unix_nano(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get count() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set count(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get sum() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set sum(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get bucket_counts() {
            return pb_1.Message.getField(this, 6) as number[];
        }
        set bucket_counts(value: number[]) {
            pb_1.Message.setField(this, 6, value);
        }
        get explicit_bounds() {
            return pb_1.Message.getField(this, 7) as number[];
        }
        set explicit_bounds(value: number[]) {
            pb_1.Message.setField(this, 7, value);
        }
        get exemplars() {
            return pb_1.Message.getRepeatedWrapperField(this, Exemplar, 8) as Exemplar[];
        }
        set exemplars(value: Exemplar[]) {
            pb_1.Message.setRepeatedWrapperField(this, 8, value);
        }
        get flags() {
            return pb_1.Message.getField(this, 10) as number;
        }
        set flags(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        static fromObject(data: {
            attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
            labels?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.StringKeyValue.prototype.toObject>[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            count?: number;
            sum?: number;
            bucket_counts?: number[];
            explicit_bounds?: number[];
            exemplars?: ReturnType<typeof Exemplar.prototype.toObject>[];
            flags?: number;
        }) {
            const message = new HistogramDataPoint({});
            if (data.attributes != null) {
                message.attributes = data.attributes.map(item => dependency_1.opentelemetry.proto.common.v1.KeyValue.fromObject(item));
            }
            if (data.labels != null) {
                message.labels = data.labels.map(item => dependency_1.opentelemetry.proto.common.v1.StringKeyValue.fromObject(item));
            }
            if (data.start_time_unix_nano != null) {
                message.start_time_unix_nano = data.start_time_unix_nano;
            }
            if (data.time_unix_nano != null) {
                message.time_unix_nano = data.time_unix_nano;
            }
            if (data.count != null) {
                message.count = data.count;
            }
            if (data.sum != null) {
                message.sum = data.sum;
            }
            if (data.bucket_counts != null) {
                message.bucket_counts = data.bucket_counts;
            }
            if (data.explicit_bounds != null) {
                message.explicit_bounds = data.explicit_bounds;
            }
            if (data.exemplars != null) {
                message.exemplars = data.exemplars.map(item => Exemplar.fromObject(item));
            }
            if (data.flags != null) {
                message.flags = data.flags;
            }
            return message;
        }
        toObject() {
            const data: {
                attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                labels?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.StringKeyValue.prototype.toObject>[];
                start_time_unix_nano?: number;
                time_unix_nano?: number;
                count?: number;
                sum?: number;
                bucket_counts?: number[];
                explicit_bounds?: number[];
                exemplars?: ReturnType<typeof Exemplar.prototype.toObject>[];
                flags?: number;
            } = {};
            if (this.attributes != null) {
                data.attributes = this.attributes.map((item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.toObject());
            }
            if (this.labels != null) {
                data.labels = this.labels.map((item: dependency_1.opentelemetry.proto.common.v1.StringKeyValue) => item.toObject());
            }
            if (this.start_time_unix_nano != null) {
                data.start_time_unix_nano = this.start_time_unix_nano;
            }
            if (this.time_unix_nano != null) {
                data.time_unix_nano = this.time_unix_nano;
            }
            if (this.count != null) {
                data.count = this.count;
            }
            if (this.sum != null) {
                data.sum = this.sum;
            }
            if (this.bucket_counts != null) {
                data.bucket_counts = this.bucket_counts;
            }
            if (this.explicit_bounds != null) {
                data.explicit_bounds = this.explicit_bounds;
            }
            if (this.exemplars != null) {
                data.exemplars = this.exemplars.map((item: Exemplar) => item.toObject());
            }
            if (this.flags != null) {
                data.flags = this.flags;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.attributes !== undefined)
                writer.writeRepeatedMessage(9, this.attributes, (item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.serialize(writer));
            if (this.labels !== undefined)
                writer.writeRepeatedMessage(1, this.labels, (item: dependency_1.opentelemetry.proto.common.v1.StringKeyValue) => item.serialize(writer));
            if (this.start_time_unix_nano !== undefined)
                writer.writeFixed64(2, this.start_time_unix_nano);
            if (this.time_unix_nano !== undefined)
                writer.writeFixed64(3, this.time_unix_nano);
            if (this.count !== undefined)
                writer.writeFixed64(4, this.count);
            if (this.sum !== undefined)
                writer.writeDouble(5, this.sum);
            if (this.bucket_counts !== undefined)
                writer.writePackedFixed64(6, this.bucket_counts);
            if (this.explicit_bounds !== undefined)
                writer.writePackedDouble(7, this.explicit_bounds);
            if (this.exemplars !== undefined)
                writer.writeRepeatedMessage(8, this.exemplars, (item: Exemplar) => item.serialize(writer));
            if (this.flags !== undefined)
                writer.writeUint32(10, this.flags);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HistogramDataPoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HistogramDataPoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 9:
                        reader.readMessage(message.attributes, () => pb_1.Message.addToRepeatedWrapperField(message, 9, dependency_1.opentelemetry.proto.common.v1.KeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.KeyValue));
                        break;
                    case 1:
                        reader.readMessage(message.labels, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_1.opentelemetry.proto.common.v1.StringKeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.StringKeyValue));
                        break;
                    case 2:
                        message.start_time_unix_nano = reader.readFixed64();
                        break;
                    case 3:
                        message.time_unix_nano = reader.readFixed64();
                        break;
                    case 4:
                        message.count = reader.readFixed64();
                        break;
                    case 5:
                        message.sum = reader.readDouble();
                        break;
                    case 6:
                        message.bucket_counts = reader.readPackedFixed64();
                        break;
                    case 7:
                        message.explicit_bounds = reader.readPackedDouble();
                        break;
                    case 8:
                        reader.readMessage(message.exemplars, () => pb_1.Message.addToRepeatedWrapperField(message, 8, Exemplar.deserialize(reader), Exemplar));
                        break;
                    case 10:
                        message.flags = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): HistogramDataPoint {
            return HistogramDataPoint.deserialize(bytes);
        }
    }
    export class ExponentialHistogramDataPoint extends pb_1.Message {
        constructor(data?: any[] | {
            attributes?: dependency_1.opentelemetry.proto.common.v1.KeyValue[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            count?: number;
            sum?: number;
            scale?: number;
            zero_count?: number;
            positive?: ExponentialHistogramDataPoint.Buckets;
            negative?: ExponentialHistogramDataPoint.Buckets;
            flags?: number;
            exemplars?: Exemplar[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 11], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("attributes" in data && data.attributes != undefined) {
                    this.attributes = data.attributes;
                }
                if ("start_time_unix_nano" in data && data.start_time_unix_nano != undefined) {
                    this.start_time_unix_nano = data.start_time_unix_nano;
                }
                if ("time_unix_nano" in data && data.time_unix_nano != undefined) {
                    this.time_unix_nano = data.time_unix_nano;
                }
                if ("count" in data && data.count != undefined) {
                    this.count = data.count;
                }
                if ("sum" in data && data.sum != undefined) {
                    this.sum = data.sum;
                }
                if ("scale" in data && data.scale != undefined) {
                    this.scale = data.scale;
                }
                if ("zero_count" in data && data.zero_count != undefined) {
                    this.zero_count = data.zero_count;
                }
                if ("positive" in data && data.positive != undefined) {
                    this.positive = data.positive;
                }
                if ("negative" in data && data.negative != undefined) {
                    this.negative = data.negative;
                }
                if ("flags" in data && data.flags != undefined) {
                    this.flags = data.flags;
                }
                if ("exemplars" in data && data.exemplars != undefined) {
                    this.exemplars = data.exemplars;
                }
            }
        }
        get attributes() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.KeyValue, 1) as dependency_1.opentelemetry.proto.common.v1.KeyValue[];
        }
        set attributes(value: dependency_1.opentelemetry.proto.common.v1.KeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get start_time_unix_nano() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set start_time_unix_nano(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get time_unix_nano() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set time_unix_nano(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get count() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set count(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get sum() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set sum(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get scale() {
            return pb_1.Message.getField(this, 6) as number;
        }
        set scale(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get zero_count() {
            return pb_1.Message.getField(this, 7) as number;
        }
        set zero_count(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get positive() {
            return pb_1.Message.getWrapperField(this, ExponentialHistogramDataPoint.Buckets, 8) as ExponentialHistogramDataPoint.Buckets;
        }
        set positive(value: ExponentialHistogramDataPoint.Buckets) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get negative() {
            return pb_1.Message.getWrapperField(this, ExponentialHistogramDataPoint.Buckets, 9) as ExponentialHistogramDataPoint.Buckets;
        }
        set negative(value: ExponentialHistogramDataPoint.Buckets) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        get flags() {
            return pb_1.Message.getField(this, 10) as number;
        }
        set flags(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        get exemplars() {
            return pb_1.Message.getRepeatedWrapperField(this, Exemplar, 11) as Exemplar[];
        }
        set exemplars(value: Exemplar[]) {
            pb_1.Message.setRepeatedWrapperField(this, 11, value);
        }
        static fromObject(data: {
            attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            count?: number;
            sum?: number;
            scale?: number;
            zero_count?: number;
            positive?: ReturnType<typeof ExponentialHistogramDataPoint.Buckets.prototype.toObject>;
            negative?: ReturnType<typeof ExponentialHistogramDataPoint.Buckets.prototype.toObject>;
            flags?: number;
            exemplars?: ReturnType<typeof Exemplar.prototype.toObject>[];
        }) {
            const message = new ExponentialHistogramDataPoint({});
            if (data.attributes != null) {
                message.attributes = data.attributes.map(item => dependency_1.opentelemetry.proto.common.v1.KeyValue.fromObject(item));
            }
            if (data.start_time_unix_nano != null) {
                message.start_time_unix_nano = data.start_time_unix_nano;
            }
            if (data.time_unix_nano != null) {
                message.time_unix_nano = data.time_unix_nano;
            }
            if (data.count != null) {
                message.count = data.count;
            }
            if (data.sum != null) {
                message.sum = data.sum;
            }
            if (data.scale != null) {
                message.scale = data.scale;
            }
            if (data.zero_count != null) {
                message.zero_count = data.zero_count;
            }
            if (data.positive != null) {
                message.positive = ExponentialHistogramDataPoint.Buckets.fromObject(data.positive);
            }
            if (data.negative != null) {
                message.negative = ExponentialHistogramDataPoint.Buckets.fromObject(data.negative);
            }
            if (data.flags != null) {
                message.flags = data.flags;
            }
            if (data.exemplars != null) {
                message.exemplars = data.exemplars.map(item => Exemplar.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                start_time_unix_nano?: number;
                time_unix_nano?: number;
                count?: number;
                sum?: number;
                scale?: number;
                zero_count?: number;
                positive?: ReturnType<typeof ExponentialHistogramDataPoint.Buckets.prototype.toObject>;
                negative?: ReturnType<typeof ExponentialHistogramDataPoint.Buckets.prototype.toObject>;
                flags?: number;
                exemplars?: ReturnType<typeof Exemplar.prototype.toObject>[];
            } = {};
            if (this.attributes != null) {
                data.attributes = this.attributes.map((item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.toObject());
            }
            if (this.start_time_unix_nano != null) {
                data.start_time_unix_nano = this.start_time_unix_nano;
            }
            if (this.time_unix_nano != null) {
                data.time_unix_nano = this.time_unix_nano;
            }
            if (this.count != null) {
                data.count = this.count;
            }
            if (this.sum != null) {
                data.sum = this.sum;
            }
            if (this.scale != null) {
                data.scale = this.scale;
            }
            if (this.zero_count != null) {
                data.zero_count = this.zero_count;
            }
            if (this.positive != null) {
                data.positive = this.positive.toObject();
            }
            if (this.negative != null) {
                data.negative = this.negative.toObject();
            }
            if (this.flags != null) {
                data.flags = this.flags;
            }
            if (this.exemplars != null) {
                data.exemplars = this.exemplars.map((item: Exemplar) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.attributes !== undefined)
                writer.writeRepeatedMessage(1, this.attributes, (item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.serialize(writer));
            if (this.start_time_unix_nano !== undefined)
                writer.writeFixed64(2, this.start_time_unix_nano);
            if (this.time_unix_nano !== undefined)
                writer.writeFixed64(3, this.time_unix_nano);
            if (this.count !== undefined)
                writer.writeFixed64(4, this.count);
            if (this.sum !== undefined)
                writer.writeDouble(5, this.sum);
            if (this.scale !== undefined)
                writer.writeSint32(6, this.scale);
            if (this.zero_count !== undefined)
                writer.writeFixed64(7, this.zero_count);
            if (this.positive !== undefined)
                writer.writeMessage(8, this.positive, () => this.positive.serialize(writer));
            if (this.negative !== undefined)
                writer.writeMessage(9, this.negative, () => this.negative.serialize(writer));
            if (this.flags !== undefined)
                writer.writeUint32(10, this.flags);
            if (this.exemplars !== undefined)
                writer.writeRepeatedMessage(11, this.exemplars, (item: Exemplar) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExponentialHistogramDataPoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExponentialHistogramDataPoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.attributes, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_1.opentelemetry.proto.common.v1.KeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.KeyValue));
                        break;
                    case 2:
                        message.start_time_unix_nano = reader.readFixed64();
                        break;
                    case 3:
                        message.time_unix_nano = reader.readFixed64();
                        break;
                    case 4:
                        message.count = reader.readFixed64();
                        break;
                    case 5:
                        message.sum = reader.readDouble();
                        break;
                    case 6:
                        message.scale = reader.readSint32();
                        break;
                    case 7:
                        message.zero_count = reader.readFixed64();
                        break;
                    case 8:
                        reader.readMessage(message.positive, () => message.positive = ExponentialHistogramDataPoint.Buckets.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.negative, () => message.negative = ExponentialHistogramDataPoint.Buckets.deserialize(reader));
                        break;
                    case 10:
                        message.flags = reader.readUint32();
                        break;
                    case 11:
                        reader.readMessage(message.exemplars, () => pb_1.Message.addToRepeatedWrapperField(message, 11, Exemplar.deserialize(reader), Exemplar));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ExponentialHistogramDataPoint {
            return ExponentialHistogramDataPoint.deserialize(bytes);
        }
    }
    export namespace ExponentialHistogramDataPoint {
        export class Buckets extends pb_1.Message {
            constructor(data?: any[] | {
                offset?: number;
                bucket_counts?: number[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("offset" in data && data.offset != undefined) {
                        this.offset = data.offset;
                    }
                    if ("bucket_counts" in data && data.bucket_counts != undefined) {
                        this.bucket_counts = data.bucket_counts;
                    }
                }
            }
            get offset() {
                return pb_1.Message.getField(this, 1) as number;
            }
            set offset(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get bucket_counts() {
                return pb_1.Message.getField(this, 2) as number[];
            }
            set bucket_counts(value: number[]) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                offset?: number;
                bucket_counts?: number[];
            }) {
                const message = new Buckets({});
                if (data.offset != null) {
                    message.offset = data.offset;
                }
                if (data.bucket_counts != null) {
                    message.bucket_counts = data.bucket_counts;
                }
                return message;
            }
            toObject() {
                const data: {
                    offset?: number;
                    bucket_counts?: number[];
                } = {};
                if (this.offset != null) {
                    data.offset = this.offset;
                }
                if (this.bucket_counts != null) {
                    data.bucket_counts = this.bucket_counts;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.offset !== undefined)
                    writer.writeSint32(1, this.offset);
                if (this.bucket_counts !== undefined)
                    writer.writePackedUint64(2, this.bucket_counts);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Buckets {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Buckets();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.offset = reader.readSint32();
                            break;
                        case 2:
                            message.bucket_counts = reader.readPackedUint64();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Buckets {
                return Buckets.deserialize(bytes);
            }
        }
    }
    export class SummaryDataPoint extends pb_1.Message {
        constructor(data?: any[] | {
            attributes?: dependency_1.opentelemetry.proto.common.v1.KeyValue[];
            labels?: dependency_1.opentelemetry.proto.common.v1.StringKeyValue[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            count?: number;
            sum?: number;
            quantile_values?: SummaryDataPoint.ValueAtQuantile[];
            flags?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [7, 1, 6], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("attributes" in data && data.attributes != undefined) {
                    this.attributes = data.attributes;
                }
                if ("labels" in data && data.labels != undefined) {
                    this.labels = data.labels;
                }
                if ("start_time_unix_nano" in data && data.start_time_unix_nano != undefined) {
                    this.start_time_unix_nano = data.start_time_unix_nano;
                }
                if ("time_unix_nano" in data && data.time_unix_nano != undefined) {
                    this.time_unix_nano = data.time_unix_nano;
                }
                if ("count" in data && data.count != undefined) {
                    this.count = data.count;
                }
                if ("sum" in data && data.sum != undefined) {
                    this.sum = data.sum;
                }
                if ("quantile_values" in data && data.quantile_values != undefined) {
                    this.quantile_values = data.quantile_values;
                }
                if ("flags" in data && data.flags != undefined) {
                    this.flags = data.flags;
                }
            }
        }
        get attributes() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.KeyValue, 7) as dependency_1.opentelemetry.proto.common.v1.KeyValue[];
        }
        set attributes(value: dependency_1.opentelemetry.proto.common.v1.KeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 7, value);
        }
        get labels() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.StringKeyValue, 1) as dependency_1.opentelemetry.proto.common.v1.StringKeyValue[];
        }
        set labels(value: dependency_1.opentelemetry.proto.common.v1.StringKeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get start_time_unix_nano() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set start_time_unix_nano(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get time_unix_nano() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set time_unix_nano(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get count() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set count(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get sum() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set sum(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get quantile_values() {
            return pb_1.Message.getRepeatedWrapperField(this, SummaryDataPoint.ValueAtQuantile, 6) as SummaryDataPoint.ValueAtQuantile[];
        }
        set quantile_values(value: SummaryDataPoint.ValueAtQuantile[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        get flags() {
            return pb_1.Message.getField(this, 8) as number;
        }
        set flags(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        static fromObject(data: {
            attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
            labels?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.StringKeyValue.prototype.toObject>[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            count?: number;
            sum?: number;
            quantile_values?: ReturnType<typeof SummaryDataPoint.ValueAtQuantile.prototype.toObject>[];
            flags?: number;
        }) {
            const message = new SummaryDataPoint({});
            if (data.attributes != null) {
                message.attributes = data.attributes.map(item => dependency_1.opentelemetry.proto.common.v1.KeyValue.fromObject(item));
            }
            if (data.labels != null) {
                message.labels = data.labels.map(item => dependency_1.opentelemetry.proto.common.v1.StringKeyValue.fromObject(item));
            }
            if (data.start_time_unix_nano != null) {
                message.start_time_unix_nano = data.start_time_unix_nano;
            }
            if (data.time_unix_nano != null) {
                message.time_unix_nano = data.time_unix_nano;
            }
            if (data.count != null) {
                message.count = data.count;
            }
            if (data.sum != null) {
                message.sum = data.sum;
            }
            if (data.quantile_values != null) {
                message.quantile_values = data.quantile_values.map(item => SummaryDataPoint.ValueAtQuantile.fromObject(item));
            }
            if (data.flags != null) {
                message.flags = data.flags;
            }
            return message;
        }
        toObject() {
            const data: {
                attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                labels?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.StringKeyValue.prototype.toObject>[];
                start_time_unix_nano?: number;
                time_unix_nano?: number;
                count?: number;
                sum?: number;
                quantile_values?: ReturnType<typeof SummaryDataPoint.ValueAtQuantile.prototype.toObject>[];
                flags?: number;
            } = {};
            if (this.attributes != null) {
                data.attributes = this.attributes.map((item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.toObject());
            }
            if (this.labels != null) {
                data.labels = this.labels.map((item: dependency_1.opentelemetry.proto.common.v1.StringKeyValue) => item.toObject());
            }
            if (this.start_time_unix_nano != null) {
                data.start_time_unix_nano = this.start_time_unix_nano;
            }
            if (this.time_unix_nano != null) {
                data.time_unix_nano = this.time_unix_nano;
            }
            if (this.count != null) {
                data.count = this.count;
            }
            if (this.sum != null) {
                data.sum = this.sum;
            }
            if (this.quantile_values != null) {
                data.quantile_values = this.quantile_values.map((item: SummaryDataPoint.ValueAtQuantile) => item.toObject());
            }
            if (this.flags != null) {
                data.flags = this.flags;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.attributes !== undefined)
                writer.writeRepeatedMessage(7, this.attributes, (item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.serialize(writer));
            if (this.labels !== undefined)
                writer.writeRepeatedMessage(1, this.labels, (item: dependency_1.opentelemetry.proto.common.v1.StringKeyValue) => item.serialize(writer));
            if (this.start_time_unix_nano !== undefined)
                writer.writeFixed64(2, this.start_time_unix_nano);
            if (this.time_unix_nano !== undefined)
                writer.writeFixed64(3, this.time_unix_nano);
            if (this.count !== undefined)
                writer.writeFixed64(4, this.count);
            if (this.sum !== undefined)
                writer.writeDouble(5, this.sum);
            if (this.quantile_values !== undefined)
                writer.writeRepeatedMessage(6, this.quantile_values, (item: SummaryDataPoint.ValueAtQuantile) => item.serialize(writer));
            if (this.flags !== undefined)
                writer.writeUint32(8, this.flags);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SummaryDataPoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SummaryDataPoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 7:
                        reader.readMessage(message.attributes, () => pb_1.Message.addToRepeatedWrapperField(message, 7, dependency_1.opentelemetry.proto.common.v1.KeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.KeyValue));
                        break;
                    case 1:
                        reader.readMessage(message.labels, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_1.opentelemetry.proto.common.v1.StringKeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.StringKeyValue));
                        break;
                    case 2:
                        message.start_time_unix_nano = reader.readFixed64();
                        break;
                    case 3:
                        message.time_unix_nano = reader.readFixed64();
                        break;
                    case 4:
                        message.count = reader.readFixed64();
                        break;
                    case 5:
                        message.sum = reader.readDouble();
                        break;
                    case 6:
                        reader.readMessage(message.quantile_values, () => pb_1.Message.addToRepeatedWrapperField(message, 6, SummaryDataPoint.ValueAtQuantile.deserialize(reader), SummaryDataPoint.ValueAtQuantile));
                        break;
                    case 8:
                        message.flags = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SummaryDataPoint {
            return SummaryDataPoint.deserialize(bytes);
        }
    }
    export namespace SummaryDataPoint {
        export class ValueAtQuantile extends pb_1.Message {
            constructor(data?: any[] | {
                quantile?: number;
                value?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("quantile" in data && data.quantile != undefined) {
                        this.quantile = data.quantile;
                    }
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get quantile() {
                return pb_1.Message.getField(this, 1) as number;
            }
            set quantile(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get value() {
                return pb_1.Message.getField(this, 2) as number;
            }
            set value(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                quantile?: number;
                value?: number;
            }) {
                const message = new ValueAtQuantile({});
                if (data.quantile != null) {
                    message.quantile = data.quantile;
                }
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    quantile?: number;
                    value?: number;
                } = {};
                if (this.quantile != null) {
                    data.quantile = this.quantile;
                }
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.quantile !== undefined)
                    writer.writeDouble(1, this.quantile);
                if (this.value !== undefined)
                    writer.writeDouble(2, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ValueAtQuantile {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ValueAtQuantile();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.quantile = reader.readDouble();
                            break;
                        case 2:
                            message.value = reader.readDouble();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ValueAtQuantile {
                return ValueAtQuantile.deserialize(bytes);
            }
        }
    }
    export class Exemplar extends pb_1.Message {
        constructor(data?: any[] | ({
            filtered_attributes?: dependency_1.opentelemetry.proto.common.v1.KeyValue[];
            filtered_labels?: dependency_1.opentelemetry.proto.common.v1.StringKeyValue[];
            time_unix_nano?: number;
            span_id?: Uint8Array;
            trace_id?: Uint8Array;
        } & (({
            as_double?: number;
            as_int?: never;
        } | {
            as_double?: never;
            as_int?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [7, 1], [[3, 6]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("filtered_attributes" in data && data.filtered_attributes != undefined) {
                    this.filtered_attributes = data.filtered_attributes;
                }
                if ("filtered_labels" in data && data.filtered_labels != undefined) {
                    this.filtered_labels = data.filtered_labels;
                }
                if ("time_unix_nano" in data && data.time_unix_nano != undefined) {
                    this.time_unix_nano = data.time_unix_nano;
                }
                if ("as_double" in data && data.as_double != undefined) {
                    this.as_double = data.as_double;
                }
                if ("as_int" in data && data.as_int != undefined) {
                    this.as_int = data.as_int;
                }
                if ("span_id" in data && data.span_id != undefined) {
                    this.span_id = data.span_id;
                }
                if ("trace_id" in data && data.trace_id != undefined) {
                    this.trace_id = data.trace_id;
                }
            }
        }
        get filtered_attributes() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.KeyValue, 7) as dependency_1.opentelemetry.proto.common.v1.KeyValue[];
        }
        set filtered_attributes(value: dependency_1.opentelemetry.proto.common.v1.KeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 7, value);
        }
        get filtered_labels() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.StringKeyValue, 1) as dependency_1.opentelemetry.proto.common.v1.StringKeyValue[];
        }
        set filtered_labels(value: dependency_1.opentelemetry.proto.common.v1.StringKeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get time_unix_nano() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set time_unix_nano(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get as_double() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set as_double(value: number) {
            pb_1.Message.setOneofField(this, 3, [3, 6], value);
        }
        get as_int() {
            return pb_1.Message.getField(this, 6) as number;
        }
        set as_int(value: number) {
            pb_1.Message.setOneofField(this, 6, [3, 6], value);
        }
        get span_id() {
            return pb_1.Message.getField(this, 4) as Uint8Array;
        }
        set span_id(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get trace_id() {
            return pb_1.Message.getField(this, 5) as Uint8Array;
        }
        set trace_id(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get value() {
            const cases: {
                [index: number]: "none" | "as_double" | "as_int";
            } = {
                0: "none",
                3: "as_double",
                6: "as_int"
            };
            return cases[pb_1.Message.computeOneofCase(this, [3, 6])];
        }
        static fromObject(data: {
            filtered_attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
            filtered_labels?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.StringKeyValue.prototype.toObject>[];
            time_unix_nano?: number;
            as_double?: number;
            as_int?: number;
            span_id?: Uint8Array;
            trace_id?: Uint8Array;
        }) {
            const message = new Exemplar({});
            if (data.filtered_attributes != null) {
                message.filtered_attributes = data.filtered_attributes.map(item => dependency_1.opentelemetry.proto.common.v1.KeyValue.fromObject(item));
            }
            if (data.filtered_labels != null) {
                message.filtered_labels = data.filtered_labels.map(item => dependency_1.opentelemetry.proto.common.v1.StringKeyValue.fromObject(item));
            }
            if (data.time_unix_nano != null) {
                message.time_unix_nano = data.time_unix_nano;
            }
            if (data.as_double != null) {
                message.as_double = data.as_double;
            }
            if (data.as_int != null) {
                message.as_int = data.as_int;
            }
            if (data.span_id != null) {
                message.span_id = data.span_id;
            }
            if (data.trace_id != null) {
                message.trace_id = data.trace_id;
            }
            return message;
        }
        toObject() {
            const data: {
                filtered_attributes?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.KeyValue.prototype.toObject>[];
                filtered_labels?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.StringKeyValue.prototype.toObject>[];
                time_unix_nano?: number;
                as_double?: number;
                as_int?: number;
                span_id?: Uint8Array;
                trace_id?: Uint8Array;
            } = {};
            if (this.filtered_attributes != null) {
                data.filtered_attributes = this.filtered_attributes.map((item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.toObject());
            }
            if (this.filtered_labels != null) {
                data.filtered_labels = this.filtered_labels.map((item: dependency_1.opentelemetry.proto.common.v1.StringKeyValue) => item.toObject());
            }
            if (this.time_unix_nano != null) {
                data.time_unix_nano = this.time_unix_nano;
            }
            if (this.as_double != null) {
                data.as_double = this.as_double;
            }
            if (this.as_int != null) {
                data.as_int = this.as_int;
            }
            if (this.span_id != null) {
                data.span_id = this.span_id;
            }
            if (this.trace_id != null) {
                data.trace_id = this.trace_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.filtered_attributes !== undefined)
                writer.writeRepeatedMessage(7, this.filtered_attributes, (item: dependency_1.opentelemetry.proto.common.v1.KeyValue) => item.serialize(writer));
            if (this.filtered_labels !== undefined)
                writer.writeRepeatedMessage(1, this.filtered_labels, (item: dependency_1.opentelemetry.proto.common.v1.StringKeyValue) => item.serialize(writer));
            if (this.time_unix_nano !== undefined)
                writer.writeFixed64(2, this.time_unix_nano);
            if (this.as_double !== undefined)
                writer.writeDouble(3, this.as_double);
            if (this.as_int !== undefined)
                writer.writeSfixed64(6, this.as_int);
            if (this.span_id !== undefined)
                writer.writeBytes(4, this.span_id);
            if (this.trace_id !== undefined)
                writer.writeBytes(5, this.trace_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Exemplar {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Exemplar();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 7:
                        reader.readMessage(message.filtered_attributes, () => pb_1.Message.addToRepeatedWrapperField(message, 7, dependency_1.opentelemetry.proto.common.v1.KeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.KeyValue));
                        break;
                    case 1:
                        reader.readMessage(message.filtered_labels, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_1.opentelemetry.proto.common.v1.StringKeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.StringKeyValue));
                        break;
                    case 2:
                        message.time_unix_nano = reader.readFixed64();
                        break;
                    case 3:
                        message.as_double = reader.readDouble();
                        break;
                    case 6:
                        message.as_int = reader.readSfixed64();
                        break;
                    case 4:
                        message.span_id = reader.readBytes();
                        break;
                    case 5:
                        message.trace_id = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Exemplar {
            return Exemplar.deserialize(bytes);
        }
    }
    export class IntDataPoint extends pb_1.Message {
        constructor(data?: any[] | {
            labels?: dependency_1.opentelemetry.proto.common.v1.StringKeyValue[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            value?: number;
            exemplars?: IntExemplar[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 5], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("labels" in data && data.labels != undefined) {
                    this.labels = data.labels;
                }
                if ("start_time_unix_nano" in data && data.start_time_unix_nano != undefined) {
                    this.start_time_unix_nano = data.start_time_unix_nano;
                }
                if ("time_unix_nano" in data && data.time_unix_nano != undefined) {
                    this.time_unix_nano = data.time_unix_nano;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("exemplars" in data && data.exemplars != undefined) {
                    this.exemplars = data.exemplars;
                }
            }
        }
        get labels() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.StringKeyValue, 1) as dependency_1.opentelemetry.proto.common.v1.StringKeyValue[];
        }
        set labels(value: dependency_1.opentelemetry.proto.common.v1.StringKeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get start_time_unix_nano() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set start_time_unix_nano(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get time_unix_nano() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set time_unix_nano(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get value() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set value(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get exemplars() {
            return pb_1.Message.getRepeatedWrapperField(this, IntExemplar, 5) as IntExemplar[];
        }
        set exemplars(value: IntExemplar[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        static fromObject(data: {
            labels?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.StringKeyValue.prototype.toObject>[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            value?: number;
            exemplars?: ReturnType<typeof IntExemplar.prototype.toObject>[];
        }) {
            const message = new IntDataPoint({});
            if (data.labels != null) {
                message.labels = data.labels.map(item => dependency_1.opentelemetry.proto.common.v1.StringKeyValue.fromObject(item));
            }
            if (data.start_time_unix_nano != null) {
                message.start_time_unix_nano = data.start_time_unix_nano;
            }
            if (data.time_unix_nano != null) {
                message.time_unix_nano = data.time_unix_nano;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.exemplars != null) {
                message.exemplars = data.exemplars.map(item => IntExemplar.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                labels?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.StringKeyValue.prototype.toObject>[];
                start_time_unix_nano?: number;
                time_unix_nano?: number;
                value?: number;
                exemplars?: ReturnType<typeof IntExemplar.prototype.toObject>[];
            } = {};
            if (this.labels != null) {
                data.labels = this.labels.map((item: dependency_1.opentelemetry.proto.common.v1.StringKeyValue) => item.toObject());
            }
            if (this.start_time_unix_nano != null) {
                data.start_time_unix_nano = this.start_time_unix_nano;
            }
            if (this.time_unix_nano != null) {
                data.time_unix_nano = this.time_unix_nano;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.exemplars != null) {
                data.exemplars = this.exemplars.map((item: IntExemplar) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.labels !== undefined)
                writer.writeRepeatedMessage(1, this.labels, (item: dependency_1.opentelemetry.proto.common.v1.StringKeyValue) => item.serialize(writer));
            if (this.start_time_unix_nano !== undefined)
                writer.writeFixed64(2, this.start_time_unix_nano);
            if (this.time_unix_nano !== undefined)
                writer.writeFixed64(3, this.time_unix_nano);
            if (this.value !== undefined)
                writer.writeSfixed64(4, this.value);
            if (this.exemplars !== undefined)
                writer.writeRepeatedMessage(5, this.exemplars, (item: IntExemplar) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IntDataPoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IntDataPoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.labels, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_1.opentelemetry.proto.common.v1.StringKeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.StringKeyValue));
                        break;
                    case 2:
                        message.start_time_unix_nano = reader.readFixed64();
                        break;
                    case 3:
                        message.time_unix_nano = reader.readFixed64();
                        break;
                    case 4:
                        message.value = reader.readSfixed64();
                        break;
                    case 5:
                        reader.readMessage(message.exemplars, () => pb_1.Message.addToRepeatedWrapperField(message, 5, IntExemplar.deserialize(reader), IntExemplar));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IntDataPoint {
            return IntDataPoint.deserialize(bytes);
        }
    }
    export class IntGauge extends pb_1.Message {
        constructor(data?: any[] | {
            data_points?: IntDataPoint[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data_points" in data && data.data_points != undefined) {
                    this.data_points = data.data_points;
                }
            }
        }
        get data_points() {
            return pb_1.Message.getRepeatedWrapperField(this, IntDataPoint, 1) as IntDataPoint[];
        }
        set data_points(value: IntDataPoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            data_points?: ReturnType<typeof IntDataPoint.prototype.toObject>[];
        }) {
            const message = new IntGauge({});
            if (data.data_points != null) {
                message.data_points = data.data_points.map(item => IntDataPoint.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                data_points?: ReturnType<typeof IntDataPoint.prototype.toObject>[];
            } = {};
            if (this.data_points != null) {
                data.data_points = this.data_points.map((item: IntDataPoint) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data_points !== undefined)
                writer.writeRepeatedMessage(1, this.data_points, (item: IntDataPoint) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IntGauge {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IntGauge();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data_points, () => pb_1.Message.addToRepeatedWrapperField(message, 1, IntDataPoint.deserialize(reader), IntDataPoint));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IntGauge {
            return IntGauge.deserialize(bytes);
        }
    }
    export class IntSum extends pb_1.Message {
        constructor(data?: any[] | {
            data_points?: IntDataPoint[];
            aggregation_temporality?: AggregationTemporality;
            is_monotonic?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data_points" in data && data.data_points != undefined) {
                    this.data_points = data.data_points;
                }
                if ("aggregation_temporality" in data && data.aggregation_temporality != undefined) {
                    this.aggregation_temporality = data.aggregation_temporality;
                }
                if ("is_monotonic" in data && data.is_monotonic != undefined) {
                    this.is_monotonic = data.is_monotonic;
                }
            }
        }
        get data_points() {
            return pb_1.Message.getRepeatedWrapperField(this, IntDataPoint, 1) as IntDataPoint[];
        }
        set data_points(value: IntDataPoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get aggregation_temporality() {
            return pb_1.Message.getField(this, 2) as AggregationTemporality;
        }
        set aggregation_temporality(value: AggregationTemporality) {
            pb_1.Message.setField(this, 2, value);
        }
        get is_monotonic() {
            return pb_1.Message.getField(this, 3) as boolean;
        }
        set is_monotonic(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            data_points?: ReturnType<typeof IntDataPoint.prototype.toObject>[];
            aggregation_temporality?: AggregationTemporality;
            is_monotonic?: boolean;
        }) {
            const message = new IntSum({});
            if (data.data_points != null) {
                message.data_points = data.data_points.map(item => IntDataPoint.fromObject(item));
            }
            if (data.aggregation_temporality != null) {
                message.aggregation_temporality = data.aggregation_temporality;
            }
            if (data.is_monotonic != null) {
                message.is_monotonic = data.is_monotonic;
            }
            return message;
        }
        toObject() {
            const data: {
                data_points?: ReturnType<typeof IntDataPoint.prototype.toObject>[];
                aggregation_temporality?: AggregationTemporality;
                is_monotonic?: boolean;
            } = {};
            if (this.data_points != null) {
                data.data_points = this.data_points.map((item: IntDataPoint) => item.toObject());
            }
            if (this.aggregation_temporality != null) {
                data.aggregation_temporality = this.aggregation_temporality;
            }
            if (this.is_monotonic != null) {
                data.is_monotonic = this.is_monotonic;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data_points !== undefined)
                writer.writeRepeatedMessage(1, this.data_points, (item: IntDataPoint) => item.serialize(writer));
            if (this.aggregation_temporality !== undefined)
                writer.writeEnum(2, this.aggregation_temporality);
            if (this.is_monotonic !== undefined)
                writer.writeBool(3, this.is_monotonic);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IntSum {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IntSum();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data_points, () => pb_1.Message.addToRepeatedWrapperField(message, 1, IntDataPoint.deserialize(reader), IntDataPoint));
                        break;
                    case 2:
                        message.aggregation_temporality = reader.readEnum();
                        break;
                    case 3:
                        message.is_monotonic = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IntSum {
            return IntSum.deserialize(bytes);
        }
    }
    export class IntHistogramDataPoint extends pb_1.Message {
        constructor(data?: any[] | {
            labels?: dependency_1.opentelemetry.proto.common.v1.StringKeyValue[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            count?: number;
            sum?: number;
            bucket_counts?: number[];
            explicit_bounds?: number[];
            exemplars?: IntExemplar[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 6, 7, 8], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("labels" in data && data.labels != undefined) {
                    this.labels = data.labels;
                }
                if ("start_time_unix_nano" in data && data.start_time_unix_nano != undefined) {
                    this.start_time_unix_nano = data.start_time_unix_nano;
                }
                if ("time_unix_nano" in data && data.time_unix_nano != undefined) {
                    this.time_unix_nano = data.time_unix_nano;
                }
                if ("count" in data && data.count != undefined) {
                    this.count = data.count;
                }
                if ("sum" in data && data.sum != undefined) {
                    this.sum = data.sum;
                }
                if ("bucket_counts" in data && data.bucket_counts != undefined) {
                    this.bucket_counts = data.bucket_counts;
                }
                if ("explicit_bounds" in data && data.explicit_bounds != undefined) {
                    this.explicit_bounds = data.explicit_bounds;
                }
                if ("exemplars" in data && data.exemplars != undefined) {
                    this.exemplars = data.exemplars;
                }
            }
        }
        get labels() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.StringKeyValue, 1) as dependency_1.opentelemetry.proto.common.v1.StringKeyValue[];
        }
        set labels(value: dependency_1.opentelemetry.proto.common.v1.StringKeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get start_time_unix_nano() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set start_time_unix_nano(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get time_unix_nano() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set time_unix_nano(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get count() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set count(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get sum() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set sum(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get bucket_counts() {
            return pb_1.Message.getField(this, 6) as number[];
        }
        set bucket_counts(value: number[]) {
            pb_1.Message.setField(this, 6, value);
        }
        get explicit_bounds() {
            return pb_1.Message.getField(this, 7) as number[];
        }
        set explicit_bounds(value: number[]) {
            pb_1.Message.setField(this, 7, value);
        }
        get exemplars() {
            return pb_1.Message.getRepeatedWrapperField(this, IntExemplar, 8) as IntExemplar[];
        }
        set exemplars(value: IntExemplar[]) {
            pb_1.Message.setRepeatedWrapperField(this, 8, value);
        }
        static fromObject(data: {
            labels?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.StringKeyValue.prototype.toObject>[];
            start_time_unix_nano?: number;
            time_unix_nano?: number;
            count?: number;
            sum?: number;
            bucket_counts?: number[];
            explicit_bounds?: number[];
            exemplars?: ReturnType<typeof IntExemplar.prototype.toObject>[];
        }) {
            const message = new IntHistogramDataPoint({});
            if (data.labels != null) {
                message.labels = data.labels.map(item => dependency_1.opentelemetry.proto.common.v1.StringKeyValue.fromObject(item));
            }
            if (data.start_time_unix_nano != null) {
                message.start_time_unix_nano = data.start_time_unix_nano;
            }
            if (data.time_unix_nano != null) {
                message.time_unix_nano = data.time_unix_nano;
            }
            if (data.count != null) {
                message.count = data.count;
            }
            if (data.sum != null) {
                message.sum = data.sum;
            }
            if (data.bucket_counts != null) {
                message.bucket_counts = data.bucket_counts;
            }
            if (data.explicit_bounds != null) {
                message.explicit_bounds = data.explicit_bounds;
            }
            if (data.exemplars != null) {
                message.exemplars = data.exemplars.map(item => IntExemplar.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                labels?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.StringKeyValue.prototype.toObject>[];
                start_time_unix_nano?: number;
                time_unix_nano?: number;
                count?: number;
                sum?: number;
                bucket_counts?: number[];
                explicit_bounds?: number[];
                exemplars?: ReturnType<typeof IntExemplar.prototype.toObject>[];
            } = {};
            if (this.labels != null) {
                data.labels = this.labels.map((item: dependency_1.opentelemetry.proto.common.v1.StringKeyValue) => item.toObject());
            }
            if (this.start_time_unix_nano != null) {
                data.start_time_unix_nano = this.start_time_unix_nano;
            }
            if (this.time_unix_nano != null) {
                data.time_unix_nano = this.time_unix_nano;
            }
            if (this.count != null) {
                data.count = this.count;
            }
            if (this.sum != null) {
                data.sum = this.sum;
            }
            if (this.bucket_counts != null) {
                data.bucket_counts = this.bucket_counts;
            }
            if (this.explicit_bounds != null) {
                data.explicit_bounds = this.explicit_bounds;
            }
            if (this.exemplars != null) {
                data.exemplars = this.exemplars.map((item: IntExemplar) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.labels !== undefined)
                writer.writeRepeatedMessage(1, this.labels, (item: dependency_1.opentelemetry.proto.common.v1.StringKeyValue) => item.serialize(writer));
            if (this.start_time_unix_nano !== undefined)
                writer.writeFixed64(2, this.start_time_unix_nano);
            if (this.time_unix_nano !== undefined)
                writer.writeFixed64(3, this.time_unix_nano);
            if (this.count !== undefined)
                writer.writeFixed64(4, this.count);
            if (this.sum !== undefined)
                writer.writeSfixed64(5, this.sum);
            if (this.bucket_counts !== undefined)
                writer.writePackedFixed64(6, this.bucket_counts);
            if (this.explicit_bounds !== undefined)
                writer.writePackedDouble(7, this.explicit_bounds);
            if (this.exemplars !== undefined)
                writer.writeRepeatedMessage(8, this.exemplars, (item: IntExemplar) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IntHistogramDataPoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IntHistogramDataPoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.labels, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_1.opentelemetry.proto.common.v1.StringKeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.StringKeyValue));
                        break;
                    case 2:
                        message.start_time_unix_nano = reader.readFixed64();
                        break;
                    case 3:
                        message.time_unix_nano = reader.readFixed64();
                        break;
                    case 4:
                        message.count = reader.readFixed64();
                        break;
                    case 5:
                        message.sum = reader.readSfixed64();
                        break;
                    case 6:
                        message.bucket_counts = reader.readPackedFixed64();
                        break;
                    case 7:
                        message.explicit_bounds = reader.readPackedDouble();
                        break;
                    case 8:
                        reader.readMessage(message.exemplars, () => pb_1.Message.addToRepeatedWrapperField(message, 8, IntExemplar.deserialize(reader), IntExemplar));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IntHistogramDataPoint {
            return IntHistogramDataPoint.deserialize(bytes);
        }
    }
    export class IntHistogram extends pb_1.Message {
        constructor(data?: any[] | {
            data_points?: IntHistogramDataPoint[];
            aggregation_temporality?: AggregationTemporality;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("data_points" in data && data.data_points != undefined) {
                    this.data_points = data.data_points;
                }
                if ("aggregation_temporality" in data && data.aggregation_temporality != undefined) {
                    this.aggregation_temporality = data.aggregation_temporality;
                }
            }
        }
        get data_points() {
            return pb_1.Message.getRepeatedWrapperField(this, IntHistogramDataPoint, 1) as IntHistogramDataPoint[];
        }
        set data_points(value: IntHistogramDataPoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get aggregation_temporality() {
            return pb_1.Message.getField(this, 2) as AggregationTemporality;
        }
        set aggregation_temporality(value: AggregationTemporality) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            data_points?: ReturnType<typeof IntHistogramDataPoint.prototype.toObject>[];
            aggregation_temporality?: AggregationTemporality;
        }) {
            const message = new IntHistogram({});
            if (data.data_points != null) {
                message.data_points = data.data_points.map(item => IntHistogramDataPoint.fromObject(item));
            }
            if (data.aggregation_temporality != null) {
                message.aggregation_temporality = data.aggregation_temporality;
            }
            return message;
        }
        toObject() {
            const data: {
                data_points?: ReturnType<typeof IntHistogramDataPoint.prototype.toObject>[];
                aggregation_temporality?: AggregationTemporality;
            } = {};
            if (this.data_points != null) {
                data.data_points = this.data_points.map((item: IntHistogramDataPoint) => item.toObject());
            }
            if (this.aggregation_temporality != null) {
                data.aggregation_temporality = this.aggregation_temporality;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.data_points !== undefined)
                writer.writeRepeatedMessage(1, this.data_points, (item: IntHistogramDataPoint) => item.serialize(writer));
            if (this.aggregation_temporality !== undefined)
                writer.writeEnum(2, this.aggregation_temporality);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IntHistogram {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IntHistogram();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.data_points, () => pb_1.Message.addToRepeatedWrapperField(message, 1, IntHistogramDataPoint.deserialize(reader), IntHistogramDataPoint));
                        break;
                    case 2:
                        message.aggregation_temporality = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IntHistogram {
            return IntHistogram.deserialize(bytes);
        }
    }
    export class IntExemplar extends pb_1.Message {
        constructor(data?: any[] | {
            filtered_labels?: dependency_1.opentelemetry.proto.common.v1.StringKeyValue[];
            time_unix_nano?: number;
            value?: number;
            span_id?: Uint8Array;
            trace_id?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("filtered_labels" in data && data.filtered_labels != undefined) {
                    this.filtered_labels = data.filtered_labels;
                }
                if ("time_unix_nano" in data && data.time_unix_nano != undefined) {
                    this.time_unix_nano = data.time_unix_nano;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("span_id" in data && data.span_id != undefined) {
                    this.span_id = data.span_id;
                }
                if ("trace_id" in data && data.trace_id != undefined) {
                    this.trace_id = data.trace_id;
                }
            }
        }
        get filtered_labels() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.opentelemetry.proto.common.v1.StringKeyValue, 1) as dependency_1.opentelemetry.proto.common.v1.StringKeyValue[];
        }
        set filtered_labels(value: dependency_1.opentelemetry.proto.common.v1.StringKeyValue[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get time_unix_nano() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set time_unix_nano(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get value() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set value(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get span_id() {
            return pb_1.Message.getField(this, 4) as Uint8Array;
        }
        set span_id(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get trace_id() {
            return pb_1.Message.getField(this, 5) as Uint8Array;
        }
        set trace_id(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            filtered_labels?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.StringKeyValue.prototype.toObject>[];
            time_unix_nano?: number;
            value?: number;
            span_id?: Uint8Array;
            trace_id?: Uint8Array;
        }) {
            const message = new IntExemplar({});
            if (data.filtered_labels != null) {
                message.filtered_labels = data.filtered_labels.map(item => dependency_1.opentelemetry.proto.common.v1.StringKeyValue.fromObject(item));
            }
            if (data.time_unix_nano != null) {
                message.time_unix_nano = data.time_unix_nano;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.span_id != null) {
                message.span_id = data.span_id;
            }
            if (data.trace_id != null) {
                message.trace_id = data.trace_id;
            }
            return message;
        }
        toObject() {
            const data: {
                filtered_labels?: ReturnType<typeof dependency_1.opentelemetry.proto.common.v1.StringKeyValue.prototype.toObject>[];
                time_unix_nano?: number;
                value?: number;
                span_id?: Uint8Array;
                trace_id?: Uint8Array;
            } = {};
            if (this.filtered_labels != null) {
                data.filtered_labels = this.filtered_labels.map((item: dependency_1.opentelemetry.proto.common.v1.StringKeyValue) => item.toObject());
            }
            if (this.time_unix_nano != null) {
                data.time_unix_nano = this.time_unix_nano;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.span_id != null) {
                data.span_id = this.span_id;
            }
            if (this.trace_id != null) {
                data.trace_id = this.trace_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.filtered_labels !== undefined)
                writer.writeRepeatedMessage(1, this.filtered_labels, (item: dependency_1.opentelemetry.proto.common.v1.StringKeyValue) => item.serialize(writer));
            if (this.time_unix_nano !== undefined)
                writer.writeFixed64(2, this.time_unix_nano);
            if (this.value !== undefined)
                writer.writeSfixed64(3, this.value);
            if (this.span_id !== undefined)
                writer.writeBytes(4, this.span_id);
            if (this.trace_id !== undefined)
                writer.writeBytes(5, this.trace_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IntExemplar {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IntExemplar();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.filtered_labels, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_1.opentelemetry.proto.common.v1.StringKeyValue.deserialize(reader), dependency_1.opentelemetry.proto.common.v1.StringKeyValue));
                        break;
                    case 2:
                        message.time_unix_nano = reader.readFixed64();
                        break;
                    case 3:
                        message.value = reader.readSfixed64();
                        break;
                    case 4:
                        message.span_id = reader.readBytes();
                        break;
                    case 5:
                        message.trace_id = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IntExemplar {
            return IntExemplar.deserialize(bytes);
        }
    }
}
